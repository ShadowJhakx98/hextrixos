<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Neural Memory Map</title>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r161/three.min.js"></script> -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
            position: fixed; /* Changed to fixed to cover whole viewport and stay behind */
            top: 0;
            left: 0;
            z-index: 1; /* Keep z-index low to stay behind UI */
        }

        /* Toggle button styling */
        #hudToggle {
                    position: absolute;
                    top: 20px;
                    left: 80px; /* Positioned after #uiToggle */
                    z-index: 200;
                    background-color: rgba(0, 255, 255, 0.2);
                    color: #0ff;
                    border: 1px solid #0ff;
                    border-radius: 50%;
                    width: 50px;
                    height: 50px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                    box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
                }
                #hudToggle:hover {
                    background-color: rgba(0, 255, 255, 0.4);
                    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                }
        #uiToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 200;
            background-color: rgba(0, 255, 255, 0.2);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        #uiToggle:hover {
            background-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        /* Fullscreen button styling */
        #fullscreenToggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 200;
            background-color: rgba(0, 255, 255, 0.2);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        #fullscreenToggle:hover {
            background-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .chat-toggle-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid rgba(0, 255, 255, 0.5);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .chat-toggle-button:hover {
            transform: scale(1.1);
            background-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .chat-toggle-button.active {
            transform: rotate(45deg);
        }

        .chat-toggle-button i {
            font-size: 24px;
        }
        /* UI Panel Container */
        #uiPanel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            pointer-events: auto; /* IMPORTANT: Changed to auto so UI elements are interactive */
        }

        #uiPanel.hidden {
            opacity: 0;
            transform: translateY(100%);
            pointer-events: none; /* Keep pointer-events none when hidden */
        }

        /* Left panel (controls) styling */
        .controls {
            position: relative;
            top: 20px;
            left: 20px;
            color: #0ff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: auto; /* Make this clickable */
            max-width: 300px;
        }

        .controls.hidden {
            transform: translateX(-120%);
        }

        /* Right panel (memory list) styling */
        .memory-list {
            position: relative;
            top: 20px;
            margin-left: auto;
            margin-right: 20px;
            color: #0ff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-height: 80vh;
            overflow-y: auto;
            width: 280px;
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: auto; /* Make this clickable */
        }

        .memory-list.hidden {
            transform: translateX(120%);
        }

        button, #clearSearch, #clearMemories, #exportMemories, #importMemories {
            background-color: rgba(0, 255, 255, 0.2);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.5);
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover, #clearSearch:hover, #clearMemories:hover, #exportMemories:hover, #importMemories:hover {
            background-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .memory-item {
            margin-bottom: 8px;
            padding: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(3px);
            display: flex;
            justify-content: space-between; /* Align text to left, button to right */
            align-items: center; /* Vertically center items */
        }

        .memory-item:hover {
            background-color: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            transform: translateX(3px);
        }

        .memory-item span {
            flex-grow: 1; /* Let text take available space */
            margin-right: 10px; /* Add some spacing between text and button */
        }

        .memory-item button.delete-memory {
            background-color: rgba(255, 0, 0, 0.3); /* Reddish for delete */
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .memory-item button.delete-memory:hover {
            background-color: rgba(255, 0, 0, 0.5);
            box-shadow: none; /* Remove glow on hover for delete button */
        }


        textarea {
            background-color: rgba(0, 0, 0, 0.5);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            padding: 8px;
            width: calc(100% - 18px);
            height: 80px;
            resize: vertical;
        }

        input[type="text"], #memorySearch {
            background-color: rgba(0, 0, 0, 0.5);
            color: #0ff;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            padding: 8px;
            width: calc(100% - 18px);
            margin-bottom: 5px;
        }

        .views {
            display: flex;
            margin-top: 10px;
        }

        .view-btn {
            flex: 1;
            font-size: 12px;
            padding: 5px;
        }

        h3 {
            margin-top: 0;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .keyword-tag {
            display: inline-block;
            background-color: rgba(0, 200, 200, 0.3);
            padding: 3px 6px;
            margin: 2px;
            border-radius: 3px;
            font-size: 12px;
        }

        .input-controls {
            margin-top: 10px;
        }
        #conversation-container {
            flex: 1; /* Let conversation container take remaining vertical space in right panel */
            overflow-y: auto; /* Enable vertical scrolling for conversation history */
            min-height: 200px; /* Minimum height for conversation container */
            background-color: rgba(0, 0, 0, 0.5); /* Example background for conversation area */
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px; /* Add some space above conversation container */
        }
        /* Glow effect for active elements */
        .active-glow {
            animation: glow 1.5s infinite alternate;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            }
            to {
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
            }
        }
                /* New HUD Panel styles */
        .hud-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 150; /* Above #uiPanel (z-index: 100) but below toggle buttons (z-index: 200) */
            background-color: #011027;
        }
        .hud-panel.active {
            display: block;
        }

        /* HUD-specific styles */
        #hud-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: 1fr 2fr 1fr;
            gap: 10px;
            padding: 20px;
            box-sizing: border-box;
        }
        .panel {
            border: 1px solid #2a9cd0;
            border-radius: 5px;
            padding: 10px;
            background-color: rgba(0, 20, 40, 0.7);
            position: relative;
            box-shadow: 0 0 10px rgba(0, 180, 255, 0.5);
            overflow: hidden;
        }
        .conversation-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background-color: rgba(0, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            transition: height 0.3s ease-in-out;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            border-top: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .conversation-panel.active {
            height: 70vh;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .panel-title {
            color: #0ff;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .panel-toggle {
            width: 40px;
            height: 5px;
            background-color: rgba(0, 255, 255, 0.5);
            border-radius: 5px;
            margin: 0 auto;
            cursor: pointer;
            transition: all 0.3s;
        }

        .panel-toggle:hover {
            background-color: rgba(0, 255, 255, 0.8);
            width: 50px;
        }

        .panel-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .conversation-history {
            flex: 2;
            overflow-y: auto;
            padding: 15px;
            border-right: 1px solid rgba(0, 255, 255, 0.2);
        }

        .media-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }

        .video-container {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .audio-visualizer {
            height: 100px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .waveform {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 100%;
            padding: 0 10px;
        }

        .waveform-bar {
            width: 3px;
            background-color: #0ff;
            border-radius: 3px;
            transition: height 0.1s ease;
        }

        .conversation-item {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            animation: fadeIn 0.3s ease-in-out;
        }

        .user-message {
            background-color: rgba(45, 50, 80, 0.5);
            border-left: 3px solid #9370DB;
        }

        .ai-message {
            background-color: rgba(20, 40, 60, 0.5);
            border-left: 3px solid #0ff;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .message-content {
            color: white;
            line-height: 1.4;
        }

        .input-container {
            display: flex;
            padding: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
        }

        .message-input {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            padding: 10px;
            margin-right: 10px;
        }

        .send-button {
            background-color: rgba(0, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0 15px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .send-button:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }

        .control-buttons {
            display: flex;
            justify-content: space-between;
            padding: 0 15px 15px;
        }

        .control-button {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: white;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-button:hover {
            background-color: rgba(0, 255, 255, 0.2);
        }

        .control-button.active {
            background-color: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.8);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Scrollbar styling */
        .conversation-history::-webkit-scrollbar {
            width: 5px;
        }

        .conversation-history::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .conversation-history::-webkit-scrollbar-thumb {
            background-color: rgba(0, 255, 255, 0.3);
            border-radius: 20px;
        }
    </style>
    <style>
        /* Google API Panels */
        #fitness-panel, #gmail-panel, #photos-panel, #drive-panel, #xr-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: rgba(0, 20, 40, 0.7);
            border: 1px solid #2a9cd0;
        }
        
        /* Fitness Panel */
        .fitness-summary {
            display: flex;
            justify-content: space-around;
            padding: 10px;
        }
        
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 10px;
            background-color: rgba(0, 50, 100, 0.5);
            border-radius: 5px;
            min-width: 60px;
        }
        
        .stat-label {
            font-size: 10px;
            color: #7fbdff;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 16px;
            color: #0ff;
            font-weight: bold;
        }
        
        .fitness-chart {
            flex: 1;
            padding: 10px;
            display: flex;
            align-items: flex-end;
            background-color: rgba(0, 30, 60, 0.3);
            border-radius: 5px;
            margin: 0 10px 10px;
        }
        
        .bar-chart {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            height: 100%;
        }
        
        .bar-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        
        .bar-container {
            width: 8px;
            height: 80%;
            background-color: rgba(0, 40, 80, 0.5);
            border-radius: 4px;
            display: flex;
            align-items: flex-end;
        }
        
        .bar {
            width: 100%;
            background-color: #0ff;
            border-radius: 4px;
            min-height: 2px;
        }
        
        .bar-label {
            font-size: 8px;
            color: #7fbdff;
            margin-top: 5px;
            text-align: center;
        }
        
        /* Gmail Panel */
        .email-list {
            overflow-y: auto;
            padding: 10px;
            flex: 1;
        }
        
        .email-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .email-item:hover {
            background-color: rgba(0, 60, 120, 0.6);
        }
        
        .email-item.unread {
            border-left: 3px solid #0ff;
        }
        
        .email-from {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .email-subject {
            font-size: 11px;
            color: #bff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .email-snippet {
            font-size: 10px;
            color: #9cc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .email-date {
            font-size: 9px;
            color: #7aa;
            text-align: right;
            margin-top: 4px;
        }
        
        /* Photos Panel */
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 5px;
            padding: 10px;
            overflow-y: auto;
            flex: 1;
        }
        
        .photo-item {
            aspect-ratio: 1;
            border-radius: 5px;
            overflow: hidden;
            background-color: rgba(0, 30, 60, 0.5);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .photo-item:hover {
            transform: scale(1.05);
        }
        
        .photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Drive Panel */
        .drive-search {
            display: flex;
            padding: 10px;
            gap: 5px;
        }
        
        #drive-search-input {
            flex: 1;
            padding: 5px 10px;
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }
        
        #drive-search-button {
            background-color: rgba(0, 255, 255, 0.3);
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
        }
        
        #drive-search-button:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }
        
        .file-list {
            overflow-y: auto;
            padding: 0 10px 10px;
            flex: 1;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 5px;
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .file-item:hover {
            background-color: rgba(0, 60, 120, 0.6);
        }
        
        .file-icon {
            font-size: 20px;
            min-width: 24px;
            text-align: center;
        }
        
        .file-details {
            flex: 1;
            overflow: hidden;
        }
        
        .file-name {
            font-size: 12px;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }
        
        .file-meta {
            font-size: 9px;
            color: #7aa;
            display: flex;
            gap: 10px;
        }
        
        /* XR Panel */
        .xr-streams {
            overflow-y: auto;
            padding: 10px;
            flex: 1;
        }
        
        .xr-stream-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 5px;
            border-left: 3px solid #7f00ff;
        }
        
        .stream-name {
            font-size: 14px;
            color: #bf7fff;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .stream-description {
            font-size: 11px;
            color: #9cc;
            margin-bottom: 10px;
        }
        
        .launch-button {
            background-color: rgba(127, 0, 255, 0.3);
            border: 1px solid rgba(127, 0, 255, 0.5);
            border-radius: 4px;
            padding: 5px 15px;
            color: #bf7fff;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .launch-button:hover {
            background-color: rgba(127, 0, 255, 0.5);
        }
        
        /* Modals */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1050;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .modal-content {
            background-color: rgba(0, 20, 40, 0.9);
            border: 2px solid #2a9cd0;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
        }
        
        .modal-content.fullscreen {
            width: 90%;
            height: 90vh;
            max-width: none;
            max-height: none;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(42, 156, 208, 0.5);
            background-color: rgba(0, 40, 80, 0.7);
        }
        
        .close-modal {
            color: #7fbdff;
            font-size: 24px;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #0ff;
        }
        
        .email-body {
            padding: 15px;
            overflow-y: auto;
            background-color: rgba(0, 30, 60, 0.5);
            flex: 1;
            color: #ddd;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .email-details {
            padding: 10px 15px;
            font-size: 12px;
            color: #9cc;
        }
        
        .photo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.5);
            flex: 1;
            overflow: hidden;
        }
        
        .photo-container img {
            max-width: 100%;
            max-height: 60vh;
            object-fit: contain;
        }
        
        .photo-details {
            padding: 10px 15px;
            font-size: 12px;
            color: #9cc;
            background-color: rgba(0, 30, 60, 0.5);
        }
        
        .file-preview-container {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.5);
            flex: 1;
            min-height: 300px;
            overflow: hidden;
        }
        
        .preview-image {
            max-width: 100%;
            max-height: 50vh;
            object-fit: contain;
        }
        
        .preview-iframe {
            width: 100%;
            height: 50vh;
            border: none;
        }
        
        .preview-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
            color: #9cc;
        }
        
        .file-icon.large {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .file-actions {
            display: flex;
            justify-content: flex-end;
            padding: 10px 15px;
            background-color: rgba(0, 40, 80, 0.7);
            gap: 10px;
        }
        
        .action-button {
            background-color: rgba(0, 255, 255, 0.3);
            border: none;
            border-radius: 4px;
            padding: 5px 15px;
            color: #fff;
            text-decoration: none;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }
        
        .action-button:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }
        
        .xr-container {
            flex: 1;
            background-color: #000;
        }
        
        .xr-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .no-data {
            padding: 20px;
            text-align: center;
            color: #7aa;
            font-style: italic;
        }
        </style>
<style>
    /* 
 * HUD Panel CSS Fixes 
 * - Makes all panels have consistent ratio
 * - Improves readability and alignment
 * - Fixes sizing issues
 */

/* Base panel styles */
.panel {
    border: 1px solid #2a9cd0;
    border-radius: 5px;
    padding: 15px;
    background-color: rgba(0, 20, 40, 0.7);
    position: relative;
    box-shadow: 0 0 10px rgba(0, 180, 255, 0.5);
    overflow: hidden;
    min-height: 150px;
    display: flex;
    flex-direction: column;
}

/* Panel header styles */
.panel-header, .header {
    border-bottom: 1px solid rgba(0, 255, 255, 0.3);
    padding-bottom: 10px;
    margin-bottom: 10px;
    font-size: 1.2rem;
    color: #0ff;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Panel content styles */
.panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
}

/* Highlight text */
.highlight {
    color: #0ff;
    font-weight: bold;
}

/* Stats section */
.stats {
    margin: 10px 0;
    font-size: 0.9rem;
    color: #7fc5f0;
}

/* Progress bar styling */
.progress-bar {
    width: 100%;
    height: 15px;
    background-color: rgba(0, 30, 60, 0.6);
    border-radius: 10px;
    margin: 5px 0 15px 0;
    overflow: hidden;
    position: relative;
}

.progress-bar-fill {
    height: 100%;
    background-color: rgba(0, 255, 255, 0.5);
    border-radius: 10px;
    position: relative;
    transition: width 0.3s ease;
}

.progress-value {
    position: absolute;
    right: 5px;
    top: 0;
    font-size: 10px;
    color: white;
    line-height: 15px;
}

/* Fix grid layout */
#hud-container {
    width: 100vw;
    height: 100vh;
    position: relative;
    display: grid;
    grid-template-columns: 1fr 2fr 1fr;
    grid-template-rows: 1fr 2fr 1fr;
    gap: 20px;
    padding: 20px;
    box-sizing: border-box;
}

/* Specific panel sizing */
#top-left, #top-right, #bottom-left, #bottom-right {
    min-height: 200px;
}

#top-center, #bottom-center {
    min-height: 200px;
}

#data-visualization, #globe-container, #side-panel {
    min-height: 300px;
}

/* Fitness tracker panel */
.fitness-tracker {
    display: flex;
    flex-direction: column;
}

.fitness-stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
}

.stat-box {
    background-color: rgba(0, 50, 80, 0.5);
    border-radius: 5px;
    padding: 10px;
    text-align: center;
    width: 30%;
}

.stat-value {
    font-size: 1.5rem;
    color: #0ff;
    font-weight: bold;
}

.stat-label {
    font-size: 0.8rem;
    color: #7fa8c9;
}

/* Gmail and Photos panels */
.gmail-inbox, .recent-photos {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.message-list, .photo-gallery {
    flex: 1;
    overflow-y: auto;
    padding: 10px 0;
}

.message-item, .photo-item {
    border-bottom: 1px solid rgba(0, 255, 255, 0.1);
    padding: 8px 0;
    display: flex;
    align-items: center;
}

.unread-count, .gallery-link {
    padding: 3px 8px;
    border-radius: 12px;
    background-color: rgba(0, 255, 255, 0.2);
    font-size: 0.8rem;
}

/* Google Drive panel */
.google-drive {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.search-box {
    display: flex;
    margin-bottom: 10px;
}

.search-input {
    flex: 1;
    background-color: rgba(0, 30, 60, 0.6);
    border: 1px solid rgba(0, 255, 255, 0.3);
    border-radius: 4px;
    color: white;
    padding: 5px 10px;
}

.search-button {
    background-color: rgba(0, 255, 255, 0.3);
    border: none;
    border-radius: 4px;
    color: white;
    padding: 5px 10px;
    margin-left: 5px;
    cursor: pointer;
}

.file-list {
    flex: 1;
    overflow-y: auto;
}

.file-item {
    display: flex;
    align-items: center;
    padding: 5px 0;
    border-bottom: 1px solid rgba(0, 255, 255, 0.1);
}

.file-icon {
    margin-right: 10px;
    color: #0ff;
}

.file-name {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.file-size {
    font-size: 0.8rem;
    color: #7fa8c9;
}

/* Empty state messages */
.empty-message {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    color: rgba(255, 255, 255, 0.5);
    font-style: italic;
}

/* Consistent fonts and text */
body, button, input {
    font-family: 'Roboto', 'Arial', sans-serif;
}

/* Animation for panel glow effect */
@keyframes panel-glow {
    0% {
        box-shadow: 0 0 5px rgba(0, 180, 255, 0.3);
    }
    50% {
        box-shadow: 0 0 15px rgba(0, 180, 255, 0.7);
    }
    100% {
        box-shadow: 0 0 5px rgba(0, 180, 255, 0.3);
    }
}

.panel.active {
    animation: panel-glow 2s infinite;
}
    </style>
    <!-- <script type="module" src="hextrix-female-model-ui.js"></script> -->

    <script>
        class MemoryNetwork {
            constructor() {
                this.nodes = [];
                this.links = [];
                this.nodeMap = new Map();
                this.categories = new Map();
                this.initialize();
            }

            initialize() {
                console.log("MemoryNetwork: initialize called"); // ADDED LOG
                this.loadMemories();
            }

            loadMemories() {
                console.log("Loading memories..."); // Keep this log
                try {
                    const history = JSON.parse(localStorage.getItem('hextrix_conversation') || '[]');
                    console.log("Conversation history loaded from localStorage:", history); // ADD THIS LOG
                    const keywords = this.extractKeywords(history);
                    console.log("Keywords extracted:", keywords); // ADD THIS LOG
                    this.createMemoryNetwork(keywords);
                    this.updateVisualization();
                } catch (error) {
                    console.error("Error in loadMemories:", error); // ADD ERROR LOG
                }
            }

            extractKeywords(history) {
                const keywords = new Set();
                history.forEach(msg => {
                    const extractedWords = this.extractWordsFromMessage(msg);
                    extractedWords.forEach(word => keywords.add(word));
                });
                return Array.from(keywords).slice(0, 50);
            }

            extractKeywordsFromMessages(messages) {
                const keywords = new Set();
                messages.forEach(msg => {
                    const extractedWords = this.extractWordsFromMessage(msg);
                    extractedWords.forEach(word => keywords.add(word));
                });
                return Array.from(keywords);
            }

            extractWordsFromMessage(msg) {
                const stopwords = ['about', 'after', 'again', 'could', 'every', 'first', 'found', 'great', 'house', 'large',
                                  'learn', 'never', 'other', 'place', 'point', 'right', 'small', 'sound', 'still', 'study',
                                  'their', 'there', 'these', 'thing', 'think', 'three', 'water', 'where', 'which', 'world',
                                  'would', 'write', 'should', 'because', 'between', 'through', 'during', 'before', 'after'];

                return msg.content
                    .toLowerCase()
                    .split(/\W+/)
                    .filter(word => word.length > 3)
                    .filter(word => !stopwords.includes(word));
            }

            createMemoryNetwork(keywords) {
                console.log("createMemoryNetwork started"); // ADD LOG at the START
                // Clear existing node map and nodes
                this.nodeMap.clear();
                this.nodes = [];

                // Create neurons and nodes
                try { // ADD try...catch INSIDE forEach loop
                    keywords.forEach((word, index) => {
                        try { // Inner try...catch for individual keyword processing
                            const category = this.categorizeWord(word);
                            const node = {
                                id: `node${index}`,
                                label: word,
                                radius: 5 + Math.random() * 3,
                                category: category,
                                strength: 1,
                                createdAt: Date.now()
                            };
                            this.nodeMap.set(word, node);
                            this.nodes.push(node);

                            // Create a Neuron object for the canvas - position it randomly for now
                            let x, y, z;
                            do {
                                x = (Math.random() * 2 - 1) * brainSize.x;
                                y = (Math.random() * 2 - 1) * brainSize.y;
                                z = (Math.random() * 2 - 1) * brainSize.z;
                            } while ((x*x)/(brainSize.x*brainSize.x) +
                                     (y*y)/(brainSize.y*brainSize.y) +
                                     (z*z)/(brainSize.z*brainSize.z) > 0.7);

                                     neurons.push(new Neuron(x, y, z, word)); // Pass 'word' as label to Neuron constructor
                                     node.neuronIndex = neurons.length - 1; 


                        } catch (innerError) {
                            console.error("Error processing keyword:", word, innerError); // Log error for each keyword
                        }
                    });

                    // Create links (connections) - basic for now, improve later
                    this.links = [];
                    for (let i = 0; i < this.nodes.length; i++) {
                        for (let j = i + 1; j < this.nodes.length; j++) {
                            if (Math.random() < 0.1) { // Adjust probability as needed
                                this.links.push({
                                    source: this.nodes[i].id,
                                    target: this.nodes[j].id,
                                    strength: 0.3,
                                    type: 'basic'
                                });
                            }
                        }
                    }

                    console.log("Memory network created with", this.nodes.length, "nodes and", this.links.length, "links"); // Keep this log
                } catch (outerError) {
                    console.error("Error in createMemoryNetwork:", outerError); // ADD outer error log
                }
                console.log("createMemoryNetwork finished"); // ADD LOG at the END
            }


            categorizeWord(word) {
                const firstChar = word.charAt(0).toLowerCase();

                if ('aeiou'.includes(firstChar)) return 'concept';
                if ('bcdfg'.includes(firstChar)) return 'entity';
                if ('hjklm'.includes(firstChar)) return 'action';
                if ('npqrs'.includes(firstChar)) return 'attribute';
                return 'relation';
            }

            addNewMemories(newKeywords, timestamp) {
                // Placeholder
            }

            updateMemories() {
                // Placeholder
            }

            updateVisualization() {
                console.log("MemoryNetwork: updateVisualization called");
                // In the future, this will update the canvas based on this.nodes and this.links
            }

            animateNewNodes() {
                // Placeholder
            }

            expandNode(node) {
                // Placeholder
            }

            highlightConnections(node) {
                // Placeholder
            }

            tick() {
                // Placeholder - not directly needed for canvas, might adapt logic
            }
            
        }
        function updateForceLayout(nodes, links) {
            if (!nodes || nodes.length === 0) return;

            const forceStrength = 0.1; // Adjust force strength as needed
            const gravityStrength = 0.01; // Gravity force to keep nodes centered
            const collideStrength = 1; // Collision force strength
            const linkDistance = brainSize.x * 0.2; // Desired link length

            // Reset forces
            nodes.forEach(node => {
                node.vx = node.vx || 0; // Initialize velocity x
                node.vy = node.vy || 0; // Initialize velocity y
                node.ax = 0;            // Initialize acceleration x
                node.ay = 0;            // Initialize acceleration y
            });


            // 1. Repulsion force (between all pairs of nodes)
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];

                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const dz = node2.z - node1.z;
                    let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distance === 0) {
                        distance = 1e-6; // Prevent division by zero
                    }

                    const repulsionForce = forceStrength * -1 / (distance * distance); // Inverse square repulsion

                    node1.ax += repulsionForce * dx / distance;
                    node1.ay += repulsionForce * dy / distance;
                    node2.ax -= repulsionForce * dx / distance;
                    node2.ay -= repulsionForce * dy / distance;
                }
            }

            // 2. Attraction force (along links)
            links.forEach(linkData => {
                const sourceNode = nodes.find(node => node.id === linkData.source);
                const targetNode = nodes.find(node => node.id === linkData.target);

                if (sourceNode && targetNode) {
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const dz = targetNode.z - sourceNode.z;
                    let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (distance === 0) {
                        distance = 1e-6; // Prevent division by zero
                    }

                    const attractionForce = forceStrength * (distance - linkDistance) / distance; // Hooke's Law attraction

                    node1.ax += attractionForce * dx / distance;
                    node1.ay += attractionForce * dy / distance;
                    node2.ax -= attractionForce * dx / distance;
                    node2.ay -= attractionForce * dy / distance;
                }
            });

            // 3. Gravity force (towards center)
            nodes.forEach(node => {
                const dx = brainCenter.x - node.x;
                const dy = brainCenter.y - node.y;
                const dz = brainCenter.z - node.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const gravityForce = gravityStrength;

                node.ax += gravityForce * dx / distance;
                node.ay += gravityForce * dy / distance;
            });


            // 4. Euler integration to update positions and velocities
            nodes.forEach(node => {
                node.vx = node.vx * 0.9 + node.ax; // Apply some damping (friction)
                node.vy = node.vy * 0.9 + node.ay;

                node.x += node.vx;
                node.y += node.vy;

                // Basic collision detection and resolution (very simplified)
                for (let otherNode of nodes) {
                    if (node !== otherNode) {
                        let dx = node.x - otherNode.x;
                        let dy = node.y - otherNode.y;
                        let dz = node.z - otherNode.z;
                        let distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        let minDist = node.radius + otherNode.radius + 10; // Minimum distance to avoid overlap

                        if (distance < minDist) {
                            let adjustFactor = (minDist - distance) * collideStrength * 0.5;
                            node.x += adjustFactor * dx / distance;
                            node.y += adjustFactor * dy / distance;
                            otherNode.x -= adjustFactor * dx / distance;
                            otherNode.y -= adjustFactor * dy / distance;
                        }
                    }
                }
            });
        }
        </script>
    <!-- <script type="module" src="index.js"></script> -->

</head>
<body>
    <canvas id="brainCanvas"></canvas>

    <!-- UI Toggle Button -->
    <div id="uiToggle">UI</div>
    <div id="fullscreenToggle">Full</div>
    <div id="hudToggle">HUD</div>
    <div class="chat-toggle-button" id="chatToggleButton">
        Chat
    </div>
    <!-- Add these buttons after the other toggle buttons in index.html -->
<div id="adultFeaturesToggle" class="chat-toggle-button" style="bottom: 90px; background-color: rgba(127, 0, 255, 0.3); border-color: rgba(127, 0, 255, 0.5);">
    <i>ðŸ”ž</i>
</div>

<!-- Add this module privacy notice somewhere near the end of the body -->
<div id="privacy-notice" style="display: none; position: fixed; bottom: 20px; left: 20px; right: 20px; background-color: rgba(0, 20, 40, 0.9); color: white; padding: 15px; border-radius: 10px; z-index: 1000; border: 1px solid rgba(0, 255, 255, 0.3);">
    <h4 style="margin-top: 0; color: #0ff;">Privacy Notice - Adult Features</h4>
    <p>Adult content and interactions are not stored permanently. Data is deleted after 24 hours by default. Gender recognition images are not stored. All features require explicit consent which can be revoked at any time.</p>
    <div style="display: flex; justify-content: flex-end; margin-top: 15px;">
        <button id="accept-privacy-notice" style="background-color: rgba(0, 255, 255, 0.3); border: none; border-radius: 5px; color: white; padding: 8px 15px; cursor: pointer;">I Understand</button>
    </div>
</div>

<!-- Add this age verification modal -->
<div id="age-verification-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 2000; display: flex; justify-content: center; align-items: center;">
    <div style="background-color: rgba(0, 20, 40, 0.9); color: white; padding: 30px; border-radius: 10px; max-width: 500px; text-align: center; border: 2px solid rgba(0, 255, 255, 0.5);">
        <h3 style="margin-top: 0; color: #0ff;">Age Verification Required</h3>
        <p>The feature you're trying to access contains adult content and requires age verification.</p>
        <p>By proceeding, you confirm that:</p>
        <ul style="text-align: left; margin: 20px 0;">
            <li>You are at least 18 years old</li>
            <li>It is legal to access adult content in your jurisdiction</li>
            <li>You understand this content is for personal, private use only</li>
        </ul>
        <div style="display: flex; justify-content: space-between; margin-top: 25px;">
            <button id="cancel-verification" style="background-color: rgba(255, 100, 100, 0.3); border: none; border-radius: 5px; color: white; padding: 10px 20px; cursor: pointer;">Cancel</button>
            <button id="confirm-age" style="background-color: rgba(0, 255, 255, 0.3); border: none; border-radius: 5px; color: white; padding: 10px 20px; cursor: pointer;">I Confirm</button>
        </div>
    </div>
</div>


    <!-- UI Panel Container -->
    <div id="uiPanel">
        <div class="controls left-panel"> <!-- Renamed and marked as left panel -->
            <h3>Hextrix Controls</h3>
            <div>
                <input type="text" id="memoryInput" placeholder="Enter a single memory...">
                <button id="addMemory">Add Memory</button>
            </div>
            <div class="input-controls">
                <textarea id="conversationInput" placeholder="Enter conversation text to extract important keywords..."></textarea>
                <button id="processConversation">Process Conversation</button>
            </div>
            <div class="views">
                <button class="view-btn" id="viewFull">Full View</button>
                <button class="view-btn" id="viewSide">Side View</button>
                <button class="view-btn" id="viewTop">Top View</button>
            </div>
        </div>

        <!-- Middle Panel for AI Interaction -->
        <div class="controls middle-panel"> <!-- New middle panel -->
            <h3>AI Interaction</h3>
            <div class="form-group">
                <label for="model-type">Select AI Model:</label>
                <select id="model-type">
                    <option value="llama">Llama 3.3 (Text)</option>
                    <option value="gemini">Gemini 2.0 (Text)</option>
                    <option value="gemma">Gemma 7B (Text)</option>
                    <option value="sd_xl">SD XL (Image Gen)</option>
                    <option value="sd_img2img">SD img2img (Image-to-Image)</option>
                    <option value="flux">Flux (Image Gen)</option>
                    <option value="whisper">Whisper (Speech-to-Text)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="user-input">Enter your question or prompt:</label>
                <textarea id="user-input" placeholder="What would you like to ask?"></textarea>
            </div>

            <button id="submit-btn">Submit</button>

            <div class="loading">
                <div class="spinner"></div>
                <p>Processing your request...</p>
            </div>

            <hr style="border-top: 1px solid rgba(0, 255, 255, 0.3); margin: 10px 0;">  <!-- Separator -->

            <div class="form-group">
                <label for="image-upload">Upload Image:</label>
                <input type="file" id="image-upload" accept="image/*"> 
            </div>
            <div id="image-preview" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">
                <!-- Image preview will be displayed here -->
            </div>
            <button id="vision-btn" disabled>Analyze Image</button> 
        </div>
        
        <div class="right-panel"> <!-- Renamed and marked as right panel -->
            <div class="memory-list">
                <h3>Memory Network</h3>
                <input type="text" id="memorySearch" placeholder="Search memories...">
                <button id="clearSearch">Clear Search</button>
                <div id="memories"></div>
                <button id="clearMemories">Clear All Memories</button>
                <button id="exportMemories">Export Memories</button>
                <button id="importMemories">Import Memories</button>
            </div>
             <div id="conversation-container">
                <!-- Conversation history will be displayed here -->
            </div>
        </div>
    </div>
    
<!-- 
  This is a template for updating the HUD panel structure in index.html 
  Replace the existing #hudPanel content with this improved structure
-->

    <div id="hudPanel" class="hud-panel">
        <div id="hud-container">
            <!-- Top row -->
            <div id="top-left" class="panel">
                <div class="header">
                    <div>SYSTEM STATUS</div>
                    <div class="highlight">ACTIVATED</div>
                </div>
                <div class="panel-content">
                    <div class="stats">CPU USAGE</div>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" style="width: 57%;">
                            <span class="progress-value">57%</span>
                        </div>
                    </div>
                    <div class="stats">MEMORY USAGE</div>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" style="width: 43%;">
                            <span class="progress-value">43%</span>
                        </div>
                    </div>
                    <div class="stats">NETWORK ACTIVITY</div>
                    <div class="progress-bar">
                        <div class="progress-bar-fill" style="width: 32%;">
                            <span class="progress-value">32%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="top-center" class="panel">
                <div class="header">
                    <div>HUD INTERFACE</div>
                    <div class="highlight">ACTIVE</div>
                </div>
                <div class="panel-content">
                    <div class="central-display">
                        <!-- Content for HUD central display -->
                        <div class="system-metrics">
                            <div class="metric-item">
                                <div class="metric-label">Uptime</div>
                                <div class="metric-value">03:45:22</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Active Processes</div>
                                <div class="metric-value">42</div>
                            </div>
                            <div class="metric-item">
                                <div class="metric-label">Neural Links</div>
                                <div class="metric-value">1,286,433</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="top-right" class="panel">
                <div class="header">
                    <div>SECURITY METRICS</div>
                    <div class="highlight">ONLINE</div>
                </div>
                <div class="panel-content">
                    <div class="security-stats">
                        <div class="stat-row">
                            <div class="stat-label">Firewall Status</div>
                            <div class="stat-value highlight">ACTIVE</div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-label">Last Scan</div>
                            <div class="stat-value">03:21:45</div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-label">Threats Detected</div>
                            <div class="stat-value">0</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Middle row -->
            <div id="data-visualization" class="panel">
                <div class="header">
                    <div>DATA ANALYSIS</div>
                    <div class="highlight">PROCESSING</div>
                </div>
                <div class="panel-content">
                    <!-- Visualization content will be dynamically generated -->
                    <div class="visualization-container">
                        <canvas id="data-canvas" height="100%"></canvas>
                    </div>
                </div>
            </div>

            <div id="globe-container" class="panel">
                <div class="header">
                    <div>NEURAL NETWORK</div>
                    <div class="highlight">ACTIVE</div>
                </div>
                <div class="panel-content">
                    <div class="radial-menu" id="radial-menu">
                        <div class="center-circle">CENTRAL<br>PROCESSING</div>
                        <div class="scan-circle"></div>
                        <div class="scan-circle" style="animation-delay: 1s;"></div>
                        <div class="scan-circle" style="animation-delay: 2s;"></div>
                        <div class="scan-circle" style="animation-delay: 3s;"></div>
                    </div>
                    <canvas id="globe" height="100%"></canvas>
                </div>
            </div>

            <div id="side-panel" class="panel">
                <div class="header">
                    <div>BIOMETRIC DATA</div>
                    <div class="highlight">MONITORING</div>
                </div>
                <div class="panel-content">
                    <!-- Biometric data visualization -->
                    <div class="biometric-container">
                        <div class="bio-metric">
                            <div class="bio-label">Heart Rate</div>
                            <div class="bio-value">72 BPM</div>
                            <div class="bio-chart mini-chart"></div>
                        </div>
                        <div class="bio-metric">
                            <div class="bio-label">Oxygen</div>
                            <div class="bio-value">98%</div>
                            <div class="bio-chart mini-chart"></div>
                        </div>
                        <div class="bio-metric">
                            <div class="bio-label">Activity</div>
                            <div class="bio-value">Moderate</div>
                            <div class="bio-chart mini-chart"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom row -->
            <div id="bottom-left" class="panel fitness-tracker">
                <div class="header">
                    <div>FITNESS TRACKER</div>
                    <div class="highlight">ACTIVE</div>
                </div>
                <div class="panel-content">
                    <div class="fitness-stats">
                        <div class="stat-box">
                            <div class="stat-value">0</div>
                            <div class="stat-label">TOTAL STEPS</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">0</div>
                            <div class="stat-label">AVG STEPS</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value">0</div>
                            <div class="stat-label">TOTAL CALORIES</div>
                        </div>
                    </div>
                    <div class="empty-message">No activity data available</div>
                </div>
            </div>

            <div id="bottom-center" class="panel gmail-inbox">
                <div class="header">
                    <div>GMAIL INBOX</div>
                    <div class="unread-count">UNREAD: 0</div>
                </div>
                <div class="panel-content">
                    <div class="message-list">
                        <div class="empty-message">No messages available</div>
                    </div>
                </div>
            </div>

            <div id="bottom-right" class="panel recent-photos">
                <div class="header">
                    <div>RECENT PHOTOS</div>
                    <div class="gallery-link">GALLERY</div>
                </div>
                <div class="panel-content">
                    <div class="photo-gallery">
                        <div class="empty-message">No photos available</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="notifications">
            <div class="notification">
                <div>System update available: v3.5.3</div>
                <div class="notification-time">12:45:22</div>
            </div>
            <div class="notification">
                <div>New data packet received</div>
                <div class="notification-time">12:43:05</div>
            </div>
        </div>
        
        <div class="dot-grid" id="dot-grid"></div>
        <div class="scan-line"></div>
    </div>
        <div class="dot-grid" id="dot-grid"></div>
        <div class="scan-line"></div>
    </div>
    <div class="conversation-panel">
        <div class="panel-toggle-container">
            <div class="panel-toggle"></div>
        </div>
        <div class="panel-header">
            <div class="panel-title">Hextrix AI Conversation</div>
            <div>
                <button class="control-button" id="clearConversation">Clear</button>
                <button class="control-button" id="exportConversation">Export</button>
            </div>
        </div>
        <div class="panel-content">
            <div class="conversation-history" id="conversationHistory">
                <!-- Conversation messages will be populated here -->
            </div>
            <div class="media-section">
                <div class="video-container" id="videoContainer">
                    <video id="videoPreview" autoplay muted style="max-width: 100%; max-height: 100%;"></video>
                </div>
                <div class="audio-visualizer">
                    <div class="waveform" id="waveform">
                        <!-- Audio waveform bars will be generated here -->
                    </div>
                    <div id="speech-input-container"></div>
                </div>
                <div class="control-buttons">
                    <button class="control-button" id="micToggle">Microphone</button>
                    <button class="control-button" id="cameraToggle">Camera</button>
                    <button class="control-button" id="screenShareToggle">Screen</button>
                </div>
            </div>
        </div>
        <div class="input-container">
            <textarea class="message-input" id="messageInput" placeholder="Type your message here..."></textarea>
            <button class="send-button" id="sendMessage">Send</button>
        </div>
    </div>

    <script>
            
                document.addEventListener('DOMContentLoaded', () => {
            const submitBtn = document.getElementById('submit-btn'); // Verify 'submit-btn' ID matches HTML button ID
            const userInput = document.getElementById('user-input');
            const modelType = document.getElementById('model-type');
            const conversationContainer = document.getElementById('conversation-container');
            const loadingDiv = document.querySelector('.loading');

            // Set the API endpoint to the Cloudflare Worker URL
            const apiUrl = 'http://127.0.0.1:5000'; // Flask server URL (default port 5000)

            // Generate a unique session ID for this browser session
            const sessionId = localStorage.getItem('hextrix_session_id') ||
                              `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            localStorage.setItem('hextrix_session_id', sessionId);

            // Load conversation history from localStorage if available
            let conversationHistory = JSON.parse(localStorage.getItem('hextrix_conversation') || '[]');

            // Display existing conversation history if available
            displayConversationHistory();

            submitBtn.addEventListener('click', async () => {
                console.log("Submit button clicked!"); //
                const input = userInput.value.trim();
                if (!input) {
                    alert('Please enter a question or prompt');
                    return;
                }

                // Add user message to UI
                addMessageToUI('user', input);

                // Clear input field
                userInput.value = '';

                // Show loading indicator
                loadingDiv.style.display = 'block';

                try {
                    const response = await fetch(`${apiUrl}/api/chat`, { // Changed API endpoint to /api/chat
                        method: 'POST', // Changed to POST request
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ // Send message in JSON body
                            message: input, // Use 'message' key to match Flask backend
                            model: modelType.value // Send selected model type
                        })
                    });

                    const data = await response.json();

                    // Hide loading indicator
                    loadingDiv.style.display = 'none';

                    if (data.error) {
                        addMessageToUI('error', data.error);
                        return;
                    }

                    // Add assistant message to UI with metadata - adjust to Flask response format
                    addMessageToUI('assistant', data.response); // Assuming Flask returns response in 'response' field

                    // Conversation history is now managed by Flask backend and memory store, 
                    // so we might not need to handle history in localStorage directly in frontend anymore
                    // if (data.history) { // Remove or adapt history handling based on Flask response
                    //     conversationHistory = data.history;
                    //     localStorage.setItem('hextrix_conversation', JSON.stringify(conversationHistory));
                    // }
                } catch (error) {
                    console.error('Error:', error);
                    loadingDiv.style.display = 'none';
                    addMessageToUI('error', 'An error occurred while processing your request.');
                }
            });
            // ... inside DOMContentLoaded listener, after submitBtn event listener ...

            const imageUpload = document.getElementById('image-upload');
            const imagePreview = document.getElementById('image-preview');
            const visionBtn = document.getElementById('vision-btn');

            let currentImageDataB64 = null; // Variable to store base64 image data

            imageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        currentImageDataB64 = e.target.result; // Store base64 data
                        imagePreview.innerHTML = `<img src="${currentImageDataB64}" style="max-width: 100%; max-height: 100%;">`; // Display preview
                        visionBtn.disabled = false; // Enable Vision button once image is loaded
                    }
                    reader.readAsDataURL(file);
                } else {
                    imagePreview.innerHTML = ''; // Clear preview if no file selected
                    visionBtn.disabled = true; // Disable Vision button if no image
                    currentImageDataB64 = null;
                }
            });

            visionBtn.addEventListener('click', async () => {
                if (!currentImageDataB64) {
                    alert('Please upload an image first.');
                    return;
                }

                // Show loading indicator (you might want a separate one for image processing)
                loadingDiv.style.display = 'block';

                try {
                    const response = await fetch(`${apiUrl}/api/vision`, { // Call Flask /api/vision endpoint
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image: currentImageDataB64, // Send base64 image data
                            prompt: userInput.value.trim() // Optionally send user prompt as well
                        })
                    });

                    const data = await response.json();

                    // Hide loading indicator
                    loadingDiv.style.display = 'none';

                    if (data.error) {
                        addMessageToUI('error', data.error);
                        return;
                    }

                    // Display vision response - adjust based on Flask response format
                    addMessageToUI('assistant', data.response); // Assuming Flask returns vision response in 'response' field

                } catch (error) {
                    console.error('Error:', error);
                    loadingDiv.style.display = 'none';
                    addMessageToUI('error', 'Error processing image analysis request.');
                }
            });
            function addMessageToUI(role, content, metadata = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}-message`;

                const roleLabel = document.createElement('div');
                roleLabel.className = 'role-label';
                roleLabel.textContent = role === 'user' ? 'You' :
                                       role === 'assistant' ? 'Hextrix AI' : 'Error';

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.textContent = content;

                messageDiv.appendChild(roleLabel);
                messageDiv.appendChild(contentDiv);

                // Add metadata if available - Removed metadata block for now
                conversationContainer.appendChild(messageDiv);

                // Scroll to the bottom of the conversation
                conversationContainer.scrollTop = conversationContainer.scrollHeight;

                // Add to local conversation history
                if (role !== 'error') {
                    const historyItem = { role, content };
                    // Only add to local history if not already in the server history
                    if (!conversationHistory.some(item =>
                        item.role === historyItem.role && item.content === historyItem.content)) {
                        conversationHistory.push(historyItem);
                        localStorage.setItem('hextrix_conversation', JSON.stringify(conversationHistory));
                    }
                }
            }

            function displayConversationHistory() {
                if (conversationHistory.length > 0) {
                    conversationHistory.forEach(item => {
                        addMessageToUI(item.role, item.content);
                    });
                }
            }
        });
        // Neuron class
        class Neuron {
            constructor(x, y, z, label = "") { // Add 'label' parameter with default empty string
                this.x = x;
                this.y = y;
                this.z = z;
                this.active = false;
                this.activeIntensity = 0;
                this.relatedNeurons = [];
                this.label = label; // Store the label text
            }

            activate() {
                this.active = true;
                this.activeIntensity = 1;
            }


            update() {
                if (this.active) {
                    this.activeIntensity = Math.max(0, this.activeIntensity - 0.02);
                    if (this.activeIntensity <= 0) {
                        this.active = false;
                    }
                }
            }

            draw() {
                // Project 3D coordinates to 2D
                const scale = 1000 / (1000 + this.z);
                const x = brainCenter.x + this.x * scale;
                const y = brainCenter.y + this.y * scale;

                ctx.beginPath();
                ctx.arc(x, y, 3 * scale, 0, Math.PI * 2);

                if (this.active) {
                    ctx.fillStyle = `rgba(0, 255, 255, ${this.activeIntensity})`;
                } else {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                }

                ctx.fill();
                ctx.fill(); // Existing circle fill code

                // Draw text label
                if (this.label) {
                    ctx.font = `12px Arial`; // Adjust font size and family as needed
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.8)'; // Label text color
                    ctx.textAlign = 'left'; // Align text to the right of the neuron
                    ctx.textBaseline = 'middle'; // Vertically center text
                    ctx.fillText(this.label, x + (3 + 5) * scale, y); // Position text to the right of circle
                }
            }
            }


        // Connection class
        class Connection {
            constructor(fromId, toId, strength) {
                this.fromId = fromId;
                this.toId = toId;
                this.strength = strength;
                this.active = false;
                this.activeIntensity = 0;
            }

            activate() {
                this.active = true;
                this.activeIntensity = 1;
            }

            update() {
                if (this.active) {
                    this.activeIntensity = Math.max(0, this.activeIntensity - 0.02);
                    if (this.activeIntensity <= 0) {
                        this.active = false;
                    }
                }
            }

            draw() {
                const from = neurons[this.fromId];
                const to = neurons[this.toId];

                // Project 3D coordinates to 2D
                const scale1 = 1000 / (1000 + from.z);
                const x1 = brainCenter.x + from.x * scale1;
                const y1 = brainCenter.y + from.y * scale1;

                const scale2 = 1000 / (1000 + to.z);
                const x2 = brainCenter.x + to.x * scale2;
                const y2 = brainCenter.y + to.y * scale2;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);

                if (this.active) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${this.activeIntensity * 0.7})`;
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${this.strength * 0.3})`;
                    ctx.lineWidth = 1;
                }

                ctx.stroke();
            }
        }

        // Canvas setup (keep as is)
        const canvas = document.getElementById('brainCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to full window size (keep as is)
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Global variables (keep and add new ones)
        let neurons = [];
        let connections = [];
        let memories = [];
        let currentView = 'full';
        let rotation = 0;
        let uiVisible = true;
        let isFullscreen = false; // Track fullscreen state
        let searchQuery = ''; // Track memory search query

        // Brain structure parameters (keep as is)
        const brainCenter = { x: canvas.width / 2, y: canvas.height / 2, z: 0 };
        const brainSize = { x: canvas.width * 0.25, y: canvas.height * 0.25, z: canvas.width * 0.25 };

        // Brain mesh data (keep as is)
        const brainMesh = {
            vertices: [],
            edges: [],
            loaded: false
        };

        // Generate brain mesh
        function generateBrainMesh() {
            // Create a more complex brain-like structure

            // Basic brain shape parameters
            const centerX = 0;
            const centerY = 0;
            const centerZ = 0;
            const brainWidth = brainSize.x * 0.8;
            const brainHeight = brainSize.y * 0.8;
            const brainDepth = brainSize.z * 0.8;

            // Generate vertices
            const vertexCount = 800;
            brainMesh.vertices = [];

            // First create the core brain shape
            for (let i = 0; i < vertexCount * 0.7; i++) {
                // Generate points in brain-like shape
                // Using a modified ellipsoid with some random variation

                // Start with angles that cover the ellipsoid
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                // Add some variations to make it more brain-like
                const r1 = 0.7 + Math.random() * 0.3; // Radius variation

                // Cerebral cortex wrinkles and folds
                const wrinkle = 0.15 * Math.sin(theta * 8) * Math.sin(phi * 6);

                // Basic ellipsoid shape with wrinkles
                let x = centerX + brainWidth * r1 * Math.sin(phi) * Math.cos(theta) * (1 + wrinkle);
                let y = centerY + brainHeight * r1 * Math.sin(phi) * Math.sin(theta) * (1 + wrinkle);
                let z = centerZ + brainDepth * r1 * Math.cos(phi) * (1 + wrinkle);

                // Add some asymmetry for a more realistic brain
                if (x > 0) {
                    x *= 1.05;
                    y *= 0.95;
                }

                // Add some more detail to the bottom part (cerebellum and brain stem area)
                if (z < 0 && y > brainHeight * 0.2) {
                    z *= 1.2;
                    y *= 0.9;
                }

                brainMesh.vertices.push({
                    x, y, z,
                    size: 1 + Math.random() * 2,
                    connCount: 0
                });
            }

            // Add some additional points in the surrounding network
            for (let i = 0; i < vertexCount * 0.3; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 1.1 + Math.random() * 0.4; // Outside the main brain

                const x = centerX + brainWidth * r * Math.sin(phi) * Math.cos(theta);
                const y = centerY + brainHeight * r * Math.sin(phi) * Math.sin(theta);
                const z = centerZ + brainDepth * r * Math.cos(phi);

                brainMesh.vertices.push({
                    x, y, z,
                    size: 0.5 + Math.random(),
                    connCount: 0
                });
            }

            // Create connections between vertices
            brainMesh.edges = [];

            // Connect points based on proximity
            for (let i = 0; i < brainMesh.vertices.length; i++) {
                const v1 = brainMesh.vertices[i];

                // Each vertex will connect to several nearby vertices
                const maxConnections = 3 + Math.floor(Math.random() * 3);
                let connections = 0;

                for (let j = 0; j < brainMesh.vertices.length && connections < maxConnections; j++) {
                    if (i === j) continue;

                    const v2 = brainMesh.vertices[j];

                    // Calculate distance between vertices
                    const dx = v1.x - v2.x;
                    const dy = v1.y - v2.y;
                    const dz = v1.z - v2.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    // Connect if within range and not too many connections
                    if (distance < brainWidth * 0.2 && v2.connCount < 6) {
                        brainMesh.edges.push({
                            from: i,
                            to: j,
                            active: false,
                            activeIntensity: 0
                        });

                        connections++;
                        v1.connCount++;
                        v2.connCount++;
                    }
                }
            }

            brainMesh.loaded = true;
        }

        // Update brain mesh
        function updateBrainMesh() {
            if (!brainMesh.loaded) return;

            // Update edge activations
            brainMesh.edges.forEach(edge => {
                if (edge.active) {
                    edge.activeIntensity = Math.max(0, edge.activeIntensity - 0.02);
                    if (edge.activeIntensity <= 0) {
                        edge.active = false;
                    }
                }
            });

            // Randomly activate some edges
            if (Math.random() < 0.1) {
                const numToActivate = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numToActivate; i++) {
                    const idx = Math.floor(Math.random() * brainMesh.edges.length);
                    brainMesh.edges[idx].active = true;
                    brainMesh.edges[idx].activeIntensity = 1;
                }
            }
        }

        // Draw brain mesh
        function drawBrainMesh() {
            if (!brainMesh.loaded) return;

            // Rotate brain mesh gradually
            rotation += 0.002;

            // Apply rotation to vertices for display
            const rotatedVertices = brainMesh.vertices.map(v => {
                // Only rotate in full view mode
                if (currentView !== 'full') {
                    return {
                        x: v.x,
                        y: v.y,
                        z: v.z,
                        size: v.size
                    };
                }

                // Apply rotation around Y axis
                const cosR = Math.cos(rotation);
                const sinR = Math.sin(rotation);

                return {
                    x: v.x * cosR + v.z * sinR,
                    y: v.y,
                    z: v.z * cosR - v.x * sinR,
                    size: v.size
                };
            });

            // Draw edges
            brainMesh.edges.forEach(edge => {
                const v1 = rotatedVertices[edge.from];
                const v2 = rotatedVertices[edge.to];

                // Project 3D coordinates to 2D
                const scale = 1000 / (1000 + v1.z);
                const x1 = brainCenter.x + v1.x * scale;
                const y1 = brainCenter.y + v1.y * scale;

                const scale2 = 1000 / (1000 + v2.z);
                const x2 = brainCenter.x + v2.x * scale2;
                const y2 = brainCenter.y + v2.y * scale2;

                // Draw connection
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);

                if (edge.active) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${edge.activeIntensity * 0.5})`;
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                }

                ctx.stroke();
            });

            // Draw vertices
            rotatedVertices.forEach(v => {
                const scale = 1000 / (1000 + v.z);
                const x = brainCenter.x + v.x * scale;
                const y = brainCenter.y + v.y * scale;

                ctx.beginPath();
                ctx.arc(x, y, v.size * scale, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fill();
                
            });
        }
        function drawNeurons(memoryNodes) {
            memoryNodes.forEach((nodeData) => {
                const neuronIndex = nodeData.neuronIndex;
                if (neuronIndex !== undefined && neurons[neuronIndex]) {
                    const neuron = neurons[neuronIndex];
                    neuron.update();
                    neuron.draw();
                } else {
                    console.warn("Warning: Neuron object not found for node:", nodeData);
                }
            });
        }
                // New function to draw connections based on memoryNetwork.links
                function drawConnections(memoryLinks) {
            memoryLinks.forEach(linkData => {
                const sourceNode = memoryNetwork.nodes.find(node => node.id === linkData.source);
                const targetNode = memoryNetwork.nodes.find(node => node.id === linkData.target);

                if (sourceNode && targetNode && sourceNode.neuronIndex !== undefined && targetNode.neuronIndex !== undefined) {
                    const fromNeuron = neurons[sourceNode.neuronIndex];
                    const toNeuron = neurons[targetNode.neuronIndex];

                    if (fromNeuron && toNeuron) {
                        // For simplicity, let's just draw a new Connection object each frame for now.
                        // In a more optimized version, you might want to manage a persistent 'connections' array
                        const tempConnection = new Connection(sourceNode.neuronIndex, targetNode.neuronIndex, linkData.strength || 0.3); // Default strength if not provided
                        tempConnection.draw(); // Draw the connection
                    } else {
                        console.warn("Warning: Neuron objects not found for link:", linkData);
                    }
                } else {
                    console.warn("Warning: Source or target node/neuron index missing for link:", linkData);
                }
            });
        }
        // Memory class
        class Memory {
            constructor(text) {
                this.text = text;
                this.neuronIds = [];
                this.connectionIds = [];
                this.lastAccessed = Date.now();
                this.keywords = [];
            }

            addNeuron(id) {
                this.neuronIds.push(id);
            }

            addConnection(id) {
                this.connectionIds.push(id);
            }

            activate() {
                this.lastAccessed = Date.now();

                // Activate neurons
                this.neuronIds.forEach(id => {
                    neurons[id].activate();
                });

                // Activate connections
                this.connectionIds.forEach(id => {
                    connections[id].activate();
                });

                // Activate brain mesh edges near memory neurons
                const numEdgesToActivate = 5 + Math.floor(Math.random() * 5);
                const indices = [];

                // Select random edges to activate
                for (let i = 0; i < numEdgesToActivate; i++) {
                    const idx = Math.floor(Math.random() * brainMesh.edges.length);
                    indices.push(idx);
                }

                // Activate them with slight delays
                indices.forEach((idx, i) => {
                    setTimeout(() => {
                        brainMesh.edges[idx].active = true;
                        brainMesh.edges[idx].activeIntensity = 1;

                        setTimeout(() => {
                            brainMesh.edges[idx].active = false;
                        }, 800 + Math.random() * 500);
                    }, i * 50);
                });
            }
        }

        // Initialize brain structure
        function initBrain() {
            // Generate brain mesh
            generateBrainMesh();

            // Create additional neurons for memories
            for (let i = 0; i < 100; i++) {
                // Random position within brain
                let x, y, z;
                do {
                    x = (Math.random() * 2 - 1) * brainSize.x;
                    y = (Math.random() * 2 - 1) * brainSize.y;
                    z = (Math.random() * 2 - 1) * brainSize.z;
                } while ((x*x)/(brainSize.x*brainSize.x) +
                         (y*y)/(brainSize.y*brainSize.y) +
                         (z*z)/(brainSize.z*brainSize.z) > 0.7);

                neurons.push(new Neuron(x, y, z));
            }

            // Create initial connections between neurons
            for (let i = 0; i < neurons.length; i++) {
                // Connect to nearby neurons
                for (let j = 0; j < neurons.length; j++) {
                    if (i !== j) {
                        const dx = neurons[i].x - neurons[j].x;
                        const dy = neurons[i].y - neurons[j].y;
                        const dz = neurons[i].z - neurons[j].z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (distance < brainSize.x * 0.3) {
                            const strength = 0.5 + Math.random() * 0.5;
                            const connectionId = connections.length;
                            connections.push(new Connection(i, j, strength));
                            neurons[i].relatedNeurons.push(j);
                            neurons[j].relatedNeurons.push(i);
                        }
                    }
                }
            }
        }

        // Update memory list in UI
        function updateMemoryList() {
            const memoryList = document.getElementById('memories');
            memoryList.innerHTML = '';

            // Sort memories by most recently accessed
            const sortedMemories = [...memories].sort((a, b) => b.lastAccessed - a.lastAccessed);

            sortedMemories.forEach(memory => {
                const memoryDiv = document.createElement('div');
                memoryDiv.className = 'memory-item';
                memoryDiv.innerText = memory.text;
                memoryDiv.addEventListener('click', () => {
                    memory.activate();
                });
                memoryList.appendChild(memoryDiv);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update brain mesh (keep)
            updateBrainMesh();
            drawBrainMesh();

            // Update force layout for neurons and links  <-- ADD THIS LINE
            updateForceLayout(memoryNetwork.nodes, memoryNetwork.links);

            // Draw neural connections (using memoryNetwork links)
            drawConnections(memoryNetwork.links);

            // Draw neurons based on memoryNetwork nodes
            drawNeurons(memoryNetwork.nodes);

            // Call updateVisualization of MemoryNetwork (keep)
            memoryNetwork.updateVisualization();
        }


        // Toggle UI visibility (Modified to toggle 'hidden' class on UI elements)
        function toggleUI() {
            const uiPanel = document.getElementById('uiPanel');
            uiVisible = !uiVisible;

            if (uiVisible) {
                uiPanel.classList.remove('hidden');
                document.querySelector('.controls').classList.remove('hidden');
                document.querySelector('.memory-list').classList.remove('hidden');
            } else {
                uiPanel.classList.add('hidden');
                document.querySelector('.controls').classList.add('hidden');
                document.querySelector('.memory-list').classList.add('hidden');
            }
        }

        // Toggle Fullscreen
        function toggleFullscreen() {
            if (!isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
                    document.documentElement.msRequestFullscreen();
                }
                isFullscreen = true;
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                isFullscreen = false;
            }
        }

            // Simulate random thoughts - activate random neurons and connections
            if (Math.random() < 0.02) {
                // Activate a random neuron
                if (neurons.length > 0) {
                    const neuronIndex = Math.floor(Math.random() * neurons.length);
                    neurons[neuronIndex].activate();
                }
            }
            if (Math.random() < 0.01 && connections.length > 0) {
                const connectionIndex = Math.floor(Math.random() * connections.length);
                connections[connectionIndex].activate();
            }


            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw brain mesh
            updateBrainMesh();
            drawBrainMesh();

            // Update and draw neural connections
            connections.forEach(conn => {
                conn.update();
                conn.draw();
            });

            // Update and draw neurons
            neurons.forEach(neuron => {
                neuron.update();
                neuron.draw();
            });
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Simulate random thoughts - activate random neurons and connections
            if (Math.random() < 0.02) {
                // Activate a random neuron
                if (neurons.length > 0) {
                    const neuronIndex = Math.floor(Math.random() * neurons.length);
                    neurons[neuronIndex].activate();
                }
            }
            if (Math.random() < 0.01 && connections.length > 0) {
                const connectionIndex = Math.floor(Math.random() * connections.length);
                connections[connectionIndex].activate();
            }

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw brain mesh
            updateBrainMesh();
            drawBrainMesh();

            // Update and draw neural connections
            connections.forEach(conn => {
                conn.update();
                conn.draw();
            });

            // Update and draw neurons
            neurons.forEach(neuron => {
                neuron.update();
                neuron.draw();
            });
        }
            // HUD Toggle
            let hudInitialized = false;
            document.getElementById('hudToggle').addEventListener('click', () => {
                const hudPanel = document.getElementById('hudPanel');
                const uiPanel = document.getElementById('uiPanel');
                hudPanel.classList.toggle('active');
                const isActive = hudPanel.classList.contains('active');
                window.toggleHUD(isActive);

                if (isActive) {
                    uiPanel.classList.add('hidden');
                    if (!hudInitialized) {
                        // Additional initialization if needed
                        hudInitialized = true;
                    }
                } else {
                    uiPanel.classList.remove('hidden');
                }
            });

        // Handle window resize (keep as is)
        window.addEventListener('resize', () => { /* ... */ });

        // Create a new memory (keep as is)
        function createMemory(text) { /* ... */ }

        // Process conversation to extract keywords (keep as is)
        function processConversation(text) { /* ... */ }


        // Save state to localStorage (keep as is)
        function saveState() { /* ... */ }

        // Load state from localStorage (keep as is)
        function loadState() { /* ... */ }

        // Export memories to JSON file (keep as is)
        function exportMemories() { /* ... */ }

        // Import memories from JSON file (keep as is)
        function importMemories() { /* ... */ }

        // Clear search function (keep as is)
        function clearSearch() { /* ... */ }

        // Clear all memories function (keep as is)
        function clearAllMemories() { /* ... */ }


        // Keyboard shortcuts (keep and add search focus)
        document.addEventListener('keydown', function(event) { /* ... */ });


        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize brain
            initBrain();
            // Instantiate MemoryNetwork
            const memoryNetwork = new MemoryNetwork(); // Instantiate here

            loadState(); // Load saved state on startup
            updateMemoryList(); // Initial memory list update

            // Save state every minute
            setInterval(saveState, 60000);


            // Add event listeners for buttons
            document.getElementById('uiToggle').addEventListener('click', toggleUI);
            document.getElementById('fullscreenToggle').addEventListener('click', toggleFullscreen);
            document.getElementById('addMemory').addEventListener('click', () => {
                const input = document.getElementById('memoryInput');
                if (input.value.trim()) {
                    createMemory(input.value.trim());
                    input.value = '';
                }
            });

            document.getElementById('memoryInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    createMemory(e.target.value.trim());
                    e.target.value = '';
                }
            });

            document.getElementById('processConversation').addEventListener('click', () => {
                const input = document.getElementById('conversationInput');
                const text = input.value.trim();
                if (text) {
                    processConversation(text);
                    input.value = '';
                }
            });

            document.getElementById('viewFull').addEventListener('click', () => { currentView = 'full'; animate(); });
            document.getElementById('viewSide').addEventListener('click', () => { currentView = 'side'; animate(); });
            document.getElementById('viewTop').addEventListener('click', () => { currentView = 'top'; animate(); });
            document.getElementById('memorySearch').addEventListener('input', (e) => {
                searchQuery = e.target.value;
                updateMemoryList();
            });
            document.getElementById('clearSearch').addEventListener('click', clearSearch);
            document.getElementById('clearMemories').addEventListener('click', clearAllMemories);
            document.getElementById('exportMemories').addEventListener('click', exportMemories);
            document.getElementById('importMemories').addEventListener('click', importMemories);


            // Start animation loop
            animate();
        });
        
    </script>
    <!-- <script src="index.js"></script> -->
<style>
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.03);
    border-left: 3px solid var(--accent-blue);
}

.user-message {
    border-left-color: var(--accent-purple);
}

.assistant-message {
    border-left-color: var(--accent-blue);
}

.error-message {
    border-left-color: #ff4444;
}

.role-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.message-content {
    color: var(--text-primary);
    line-height: 1.6;
    font-size: 1rem;
}
.message {
    margin-bottom: 20px;
    padding: 15px;
    border-radius: 8px;
}

</style>
    <!-- HUD Libraries (add only if not already present) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/shaders/CopyShader.js"></script>
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.js"></script>
    <!-- HUD Script wrapped in IIFE -->
    <script>
        (function() {
            let isHUDActive = false;

            function initGlobe() {
                const container = document.getElementById('globe-container');
                const canvas = document.getElementById('globe');
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.z = 2;
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);

                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(container.clientWidth, container.clientHeight), 1.5, 0.4, 0.85
                );
                const composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // Globe setup (copy from original HUD code)
                const globeGeometry = new THREE.SphereGeometry(0.8, 32, 32);
                const globeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0066aa,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.6
                });
                const globe = new THREE.Mesh(globeGeometry, globeMaterial);
                scene.add(globe);

                // Additional globe elements (glow, particles, etc.)
                // Copy from original HUD code

                function animate() {
                    if (!isHUDActive) {
                        requestAnimationFrame(animate);
                        return;
                    }
                    globe.rotation.y += 0.002;
                    // Other animation logic
                    composer.render();
                    requestAnimationFrame(animate);
                }
                animate();

                window.addEventListener('resize', () => {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    composer.setSize(container.clientWidth, container.clientHeight);
                });
            }

            function initCharts() {
                // Copy chart initialization from HUD code
            }

            function createDotGrid() {
                // Copy dot grid creation from HUD code
            }

            // Initialize HUD when DOM is loaded
            document.addEventListener('DOMContentLoaded', () => {
                initGlobe();
                initCharts();
                createDotGrid();
                // Notification interval logic
            });

            // Expose toggle function
            window.toggleHUD = function(state) {
                isHUDActive = state;
            };
        })();
    </script>
    <script>
        // Conversation Panel Functionality
document.addEventListener('DOMContentLoaded', function() {
    // Variables and elements
    const panel = document.querySelector('.conversation-panel');
    const toggleButton = document.createElement('div');
    toggleButton.className = 'chat-toggle-button';
    toggleButton.id = 'chatToggleButton';
    toggleButton.innerHTML = '<i>ðŸ’¬</i>';
    document.body.appendChild(toggleButton);
    
    const panelToggle = document.querySelector('.panel-toggle');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendMessage');
    const clearConversationBtn = document.getElementById('clearConversation');
    const exportConversationBtn = document.getElementById('exportConversation');
    const micToggleBtn = document.getElementById('micToggle');
    const cameraToggleBtn = document.getElementById('cameraToggle');
    const screenShareToggleBtn = document.getElementById('screenShareToggle');
    
    // Create waveform bars
    const waveform = document.getElementById('waveform');
    if (waveform) {
        for (let i = 0; i < 50; i++) {
            const bar = document.createElement('div');
            bar.className = 'waveform-bar';
            bar.style.height = '3px';
            waveform.appendChild(bar);
        }
    }
    
    // Toggle panel functionality
    toggleButton.addEventListener('click', () => {
        panel.classList.toggle('active');
        toggleButton.classList.toggle('active');
        
        // Load conversation history when opened
        if (panel.classList.contains('active')) {
            loadConversationHistory();
        }
    });
    
    // Panel toggle to close
    if (panelToggle) {
        panelToggle.addEventListener('click', () => {
            panel.classList.remove('active');
            if (toggleButton) toggleButton.classList.remove('active');
        });
    }
    
    // Handle message sending
    if (sendButton && messageInput) {
        sendButton.addEventListener('click', () => {
            if (messageInput.value.trim()) {
                sendMessage(messageInput.value);
                messageInput.value = '';
            }
        });
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendButton.click();
            }
        });
    }
    
    // Add other event listeners
    if (clearConversationBtn) clearConversationBtn.addEventListener('click', clearConversation);
    if (exportConversationBtn) exportConversationBtn.addEventListener('click', exportConversation);
    if (micToggleBtn) micToggleBtn.addEventListener('click', toggleMicrophone);
    if (cameraToggleBtn) cameraToggleBtn.addEventListener('click', toggleCamera);
    if (screenShareToggleBtn) screenShareToggleBtn.addEventListener('click', toggleScreenShare);
    
    // Initialize audio analyzer
    initAudioAnalyzer();
});

// Function to load conversation history from the server
async function loadConversationHistory() {
    try {
        const response = await fetch('/api/conversation/history');
        const data = await response.json();
        
        const historyContainer = document.getElementById('conversationHistory');
        historyContainer.innerHTML = '';
        
        if (data.conversations && data.conversations.length > 0) {
            data.conversations.forEach(item => {
                addMessageToHistory('user', item.user_message, new Date(item.timestamp));
                addMessageToHistory('ai', item.ai_response, new Date(item.timestamp));
            });
            
            // Scroll to bottom
            historyContainer.scrollTop = historyContainer.scrollHeight;
        }
    } catch (error) {
        console.error('Error loading conversation history:', error);
    }
}

// Function to add a message to the conversation history
function addMessageToHistory(role, content, timestamp = new Date()) {
    const historyContainer = document.getElementById('conversationHistory');
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `conversation-item ${role === 'user' ? 'user-message' : 'ai-message'}`;
    
    const header = document.createElement('div');
    header.className = 'message-header';
    
    const sender = document.createElement('span');
    sender.textContent = role === 'user' ? 'You' : 'Hextrix AI';
    
    const time = document.createElement('span');
    time.textContent = formatTimestamp(timestamp);
    
    header.appendChild(sender);
    header.appendChild(time);
    
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    messageContent.textContent = content;
    
    messageDiv.appendChild(header);
    messageDiv.appendChild(messageContent);
    
    historyContainer.appendChild(messageDiv);
    
    // Scroll to the new message
    historyContainer.scrollTop = historyContainer.scrollHeight;
    
    // Make sure the panel is visible when new messages arrive
    const panel = document.querySelector('.conversation-panel');
    const toggleButton = document.getElementById('chatToggleButton');
    
    // Only auto-open the panel when AI responds (not for user messages)
    if (role === 'ai' && !panel.classList.contains('active')) {
        panel.classList.add('active');
        toggleButton.classList.add('active');
    }
}

// Function to send a message to the server
async function sendMessage(message) {
    if (!message.trim()) return;
    
    // Add user message to history immediately
    addMessageToHistory('user', message);
    
    try {
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                model: document.getElementById('model-type')?.value || 'llama'
            })
        });
        
        const data = await response.json();
        
        // Add AI response to history
        if (data.response) {
            addMessageToHistory('ai', data.response);
        }
    } catch (error) {
        console.error('Error sending message:', error);
        addMessageToHistory('ai', 'Sorry, I encountered an error processing your request.');
    }
}

// Helper function to format timestamps
function formatTimestamp(date) {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

// Toggle microphone functionality
let audioContext;
let audioAnalyser;
let microphone;
let isRecording = false;

async function toggleMicrophone() {
    const micToggle = document.getElementById('micToggle');
    
    if (!isRecording) {
        try {
            // Start recording
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            // Initialize audio context if not already created
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;
            }
            
            microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(audioAnalyser);
            
            isRecording = true;
            micToggle.classList.add('active');
            
            // Start visualization
            updateWaveform();
        } catch (error) {
            console.error('Error accessing microphone:', error);
            alert('Could not access the microphone. Please check permissions.');
        }
    } else {
        // Stop recording
        if (microphone) {
            microphone.disconnect();
            microphone = null;
        }
        
        isRecording = false;
        micToggle.classList.remove('active');
    }
}

// Initialize audio analyzer for waveform
function initAudioAnalyzer() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioAnalyser = audioContext.createAnalyser();
        audioAnalyser.fftSize = 256;
    } catch (error) {
        console.error('Error initializing audio analyzer:', error);
    }
}

// Update waveform visualization
function updateWaveform() {
    if (!isRecording) return;
    
    const bufferLength = audioAnalyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    audioAnalyser.getByteFrequencyData(dataArray);
    
    const bars = document.querySelectorAll('.waveform-bar');
    const step = Math.floor(bufferLength / bars.length);
    
    for (let i = 0; i < bars.length; i++) {
        const value = dataArray[i * step];
        const height = Math.max(3, value / 2); // Scale height (max 128)
        bars[i].style.height = `${height}px`;
    }
    
    requestAnimationFrame(updateWaveform);
}

// Video Processing Integration
document.addEventListener('DOMContentLoaded', function() {
    // Initialize video-related elements
    const videoContainer = document.getElementById('videoContainer');
    const videoPreview = document.getElementById('videoPreview');
    const cameraToggle = document.getElementById('cameraToggle');
    const screenShareToggle = document.getElementById('screenShareToggle');
    
    // Connect to Socket.IO
    const socket = io();
    
    // Set up Socket.IO event handlers
    socket.on('connect', function() {
        console.log('Connected to server via Socket.IO');
    });
    
    socket.on('disconnect', function() {
        console.log('Disconnected from server');
    });
    
    // Handle processed video frames
    socket.on('processed_frame', function(data) {
        console.log('Received processed frame:', data);
        
        // Display the results in the conversation
        if (data.pipeline_results) {
            let resultText = '';
            
            if (data.pipeline_results.used_hybrid_pipeline) {
                resultText = data.pipeline_results.final_analysis;
            } else if (data.pipeline_results.used_fallback) {
                resultText = data.pipeline_results.analysis;
            }
            
            if (resultText) {
                addMessageToHistory('ai', resultText);
            }
        }
    });
    
    // Handle processed screen captures
    socket.on('processed_screen', function(data) {
        console.log('Received processed screen data:', data);
        
        // Display the results in the conversation
        if (data.pipeline_results) {
            let resultText = '';
            
            if (data.pipeline_results.used_hybrid_pipeline) {
                resultText = data.pipeline_results.final_analysis;
            } else if (data.pipeline_results.used_fallback) {
                resultText = data.pipeline_results.analysis;
            }
            
            if (resultText) {
                addMessageToHistory('ai', resultText);
            }
        }
    });
    
    // Handle Kinect status updates
    socket.on('kinect_status', function(data) {
        if (data.status === 'error') {
            // Show error message in video container
            videoContainer.innerHTML = `
                <div class="camera-error">
                    <div class="error-icon">ðŸ“·âŒ</div>
                    <div class="error-message">${data.message}</div>
                    <div class="error-info">Check camera connections or permissions</div>
                </div>
            `;
        }
    });
    
    // Camera toggle functionality
    let cameraStream = null;
    
    async function toggleCamera() {
        if (!cameraStream) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                videoPreview.srcObject = stream;
                cameraStream = stream;
                
                if (cameraToggle) {
                    cameraToggle.classList.add('active');
                }
                
                // Set up frame sending
                startFrameSending(stream);
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                if (videoContainer) {
                    videoContainer.innerHTML = `
                        <div class="camera-error">
                            <div class="error-icon">ðŸ“·âŒ</div>
                            <div class="error-message">Could not access camera: ${error.message}</div>
                            <div class="error-info">Please check camera permissions</div>
                        </div>
                    `;
                }
            }
        } else {
            // Stop camera
            stopFrameSending();
            
            cameraStream.getTracks().forEach(track => track.stop());
            videoPreview.srcObject = null;
            cameraStream = null;
            
            if (cameraToggle) {
                cameraToggle.classList.remove('active');
            }
        }
    }
    
    // Screen sharing functionality
    let screenStream = null;
    
    async function toggleScreenShare() {
        if (!screenStream) {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: {
                        cursor: "always"
                    }
                });
                
                videoPreview.srcObject = stream;
                screenStream = stream;
                
                if (screenShareToggle) {
                    screenShareToggle.classList.add('active');
                }
                
                // Handle stream ending (user stops sharing)
                stream.getVideoTracks()[0].onended = () => {
                    videoPreview.srcObject = null;
                    screenStream = null;
                    stopFrameSending();
                    
                    if (screenShareToggle) {
                        screenShareToggle.classList.remove('active');
                    }
                };
                
                // Start sending frames for analysis
                startScreenSending(stream);
                
            } catch (error) {
                console.error('Error sharing screen:', error);
            }
        } else {
            // Stop screen sharing
            stopFrameSending();
            
            screenStream.getTracks().forEach(track => track.stop());
            videoPreview.srcObject = null;
            screenStream = null;
            
            if (screenShareToggle) {
                screenShareToggle.classList.remove('active');
            }
        }
    }
    
    // Frame processing for camera input
    let frameInterval = null;
    const frameRate = 1; // 1 frame per second to reduce processing load
    
    function startFrameSending(stream) {
        // Create a hidden canvas element to capture frames
        const canvas = document.createElement('canvas');
        canvas.width = 640;
        canvas.height = 480;
        const ctx = canvas.getContext('2d');
        
        // Clear any existing interval
        if (frameInterval) {
            clearInterval(frameInterval);
        }
        
        // Start processing frames
        frameInterval = setInterval(() => {
            try {
                // Draw current video frame to canvas
                ctx.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);
                
                // Get the image data as base64
                const imageData = canvas.toDataURL('image/jpeg', 0.7);
                
                // Send to server for processing
                socket.emit('video_frame', {
                    image: imageData
                });
                
                // Visual feedback that frame was captured
                if (videoContainer) {
                    videoContainer.classList.add('processing');
                    setTimeout(() => {
                        videoContainer.classList.remove('processing');
                    }, 200);
                }
                
            } catch (error) {
                console.error('Error capturing video frame:', error);
            }
        }, 1000 / frameRate);
    }
    
    // Screen sharing capture and processing
    function startScreenSending(stream) {
        // Create a hidden canvas element to capture frames
        const canvas = document.createElement('canvas');
        canvas.width = 1280;
        canvas.height = 720;
        const ctx = canvas.getContext('2d');
        
        // Clear any existing interval
        if (frameInterval) {
            clearInterval(frameInterval);
        }
        
        // Start processing frames at a lower rate for screen shares
        frameInterval = setInterval(() => {
            try {
                // Draw current video frame to canvas
                ctx.drawImage(videoPreview, 0, 0, canvas.width, canvas.height);
                
                // Get the image data as base64
                const imageData = canvas.toDataURL('image/jpeg', 0.5); // Lower quality for speed
                
                // Send to server for processing
                socket.emit('screen_share', {
                    image: imageData
                });
                
                // Visual feedback
                if (videoContainer) {
                    videoContainer.classList.add('processing');
                    setTimeout(() => {
                        videoContainer.classList.remove('processing');
                    }, 200);
                }
                
            } catch (error) {
                console.error('Error capturing screen frame:', error);
            }
        }, 3000); // One frame every 3 seconds for screen shares
    }
    
    // Stop frame processing
    function stopFrameSending() {
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }
    }
    
    // Add event listeners to buttons
    if (cameraToggle) {
        cameraToggle.addEventListener('click', toggleCamera);
    }
    
    if (screenShareToggle) {
        screenShareToggle.addEventListener('click', toggleScreenShare);
    }
    
    // Add camera CSS to help with visual feedback
    const style = document.createElement('style');
    style.textContent = `
        .video-container.processing {
            border: 2px solid #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        
        .camera-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #ff5555;
            text-align: center;
            padding: 20px;
        }
        
        .error-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .error-message {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .error-info {
            font-size: 0.9em;
            opacity: 0.8;
        }
    `;
    document.head.appendChild(style);
});


// Clear conversation history
function clearConversation() {
    if (confirm('Are you sure you want to clear the conversation history?')) {
        document.getElementById('conversationHistory').innerHTML = '';
        // You might want to also clear server-side history with an API call
    }
}

// Export conversation history
function exportConversation() {
    const historyContainer = document.getElementById('conversationHistory');
    let exportText = '';
    
    // Extract text from conversation items
    const items = historyContainer.querySelectorAll('.conversation-item');
    items.forEach(item => {
        const isUser = item.classList.contains('user-message');
        const sender = isUser ? 'You' : 'Hextrix AI';
        const content = item.querySelector('.message-content').textContent;
        const time = item.querySelector('.message-header span:last-child').textContent;
        
        exportText += `[${time}] ${sender}: ${content}\n\n`;
    });
    
    // Create download link
    const blob = new Blob([exportText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `hextrix-conversation-${new Date().toISOString().slice(0, 10)}.txt`;
    a.click();
    
    // Clean up
    URL.revokeObjectURL(url);
}
    </script>
    <script type="text/babel">
        import React, { useState, useRef, useEffect } from 'react';
import io from 'socket.io-client';

const SpeechInputPanel = () => {
    const [isListening, setIsListening] = useState(false);
    const [transcript, setTranscript] = useState('');
    const [interimTranscript, setInterimTranscript] = useState('');
    const [searchType, setSearchType] = useState('text');
    const [searchResults, setSearchResults] = useState(null);
    const [aiEmotion, setAiEmotion] = useState(null);
    const [perplexityContext, setPerplexityContext] = useState(null);

    const speechRecognition = useRef(null);
    const socketRef = useRef(null);

    useEffect(() => {
        // Initialize speech recognition
        speechRecognition.current = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        speechRecognition.current.continuous = true;
        speechRecognition.current.interimResults = true;
        speechRecognition.current.lang = 'en-US';

        // Initialize socket
        socketRef.current = io();

        // Socket event listeners
        socketRef.current.on('transcription_analysis', handleTranscriptionAnalysis);
        socketRef.current.on('search_results', handleSearchResults);

        // Speech recognition event handlers
        speechRecognition.current.onresult = handleSpeechResult;
        speechRecognition.current.onerror = handleSpeechError;

        // Cleanup
        return () => {
            if (socketRef.current) {
                socketRef.current.disconnect();
            }
        };
    }, []);

    const handleStartListening = () => {
        if (speechRecognition.current) {
            speechRecognition.current.start();
            setIsListening(true);
            setTranscript('');
            setInterimTranscript('');
        }
    };

    const handleStopListening = () => {
        if (speechRecognition.current) {
            speechRecognition.current.stop();
            setIsListening(false);
        }
    };

    const handleSpeechResult = (event) => {
        let interimTranscript = '';
        let finalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
            } else {
                interimTranscript += event.results[i][0].transcript;
            }
        }

        setTranscript(prev => prev + finalTranscript);
        setInterimTranscript(interimTranscript);

        // Send transcript to server for processing
        if (socketRef.current && finalTranscript.trim()) {
            socketRef.current.emit('audio_data', { 
                transcript: finalTranscript,
                timestamp: new Date().toISOString()
            });
        }
    };
    // Add this to your WebSocket event handlers
    socket.on('kinect_status', function(data) {
        const videoContainer = document.getElementById('videoContainer');
        if (data.status === 'error') {
            // Show error message in video container
            videoContainer.innerHTML = `
                <div class="camera-error">
                    <div class="error-icon">ðŸ“·âŒ</div>
                    <div class="error-message">${data.message}</div>
                    <div class="error-info">Check camera connections or permissions</div>
                </div>
            `;
        }
    });
    // Add this to your frontend JavaScript
    socket.on('processed_frame', function(data) {
        console.log('Received processed frame:', data);
        // Display the results in the conversation
        if (data.pipeline_results) {
            let resultText = '';
            
            if (data.pipeline_results.used_hybrid_pipeline) {
                resultText = data.pipeline_results.final_analysis;
            } else if (data.pipeline_results.used_fallback) {
                resultText = data.pipeline_results.analysis;
            }
            
            if (resultText) {
                addMessageToHistory('ai', resultText);
            }
        }
    });

    // Similar update for processed_screen
    socket.on('processed_screen', (data) => {
        // Similar logic as processed_frame
        if (data.pipeline_results) {
            if (data.pipeline_results.used_fallback) {
                const analysis = data.pipeline_results.analysis;
                addMessageToHistory('ai', `Screen Analysis (Local LLaVA): ${analysis}`);
            } else {
                const initialInterpretation = data.pipeline_results.initial_interpretation;
                const visionAnalysis = data.pipeline_results.vision_analysis;
                const finalAnalysis = data.pipeline_results.final_analysis;
                
                addMessageToHistory('ai', `Initial Screen Assessment (Gemini): ${initialInterpretation}`);
                addMessageToHistory('ai', `Visual Screen Elements (LLaVA): ${visionAnalysis}`);
                addMessageToHistory('ai', `Comprehensive Screen Analysis (Gemini): ${finalAnalysis}`);
            }
        }
    });
        const handleSpeechError = (event) => {
            console.error('Speech recognition error:', event);
            setIsListening(false);
            alert('Speech recognition failed. Please try again.');
        };

        const handleTranscriptionAnalysis = (data) => {
            // Update AI emotion state
            if (data.ai_emotion) {
                setAiEmotion(data.ai_emotion);
            }

            // Update Perplexity context
            if (data.perplexity_context) {
                setPerplexityContext(data.perplexity_context);
            }
        };

    const handleSearchResults = (data) => {
        setSearchResults(data.results);
    };

    const performSearch = () => {
        if (socketRef.current && transcript) {
            socketRef.current.emit('voice_search', {
                transcript,
                type: searchType
            });
        }
    };



    const renderPerplexityContext = () => {
        if (!perplexityContext || !perplexityContext.results) return null;

        return (
            <div className="perplexity-context">
                <h3>Contextual Insights</h3>
                <ul>
                    {perplexityContext.results.map((result, index) => (
                        <li key={index}>
                            <strong>{result.title}</strong>
                            <p>{result.snippet}</p>
                            <a 
                                href={result.link} 
                                target="_blank" 
                                rel="noopener noreferrer"
                            >
                                Learn More
                            </a>
                        </li>
                    ))}
                </ul>
            </div>
        );
    };

    const renderSearchResults = () => {
        if (!searchResults) return null;

        return (
            <div className="search-results">
                <h3>Search Results</h3>
                {searchType === 'text' && searchResults.organic_results && (
                    <ul>
                        {searchResults.organic_results.map((result, index) => (
                            <li key={index}>
                                <h4>{result.title}</h4>
                                <p>{result.snippet}</p>
                                <a 
                                    href={result.link} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                >
                                    {result.link}
                                </a>
                            </li>
                        ))}
                    </ul>
                )}
                {searchType === 'image' && searchResults.images_results && (
                    <div className="image-results">
                        {searchResults.images_results.map((image, index) => (
                            <img 
                                key={index} 
                                src={image.thumbnail} 
                                alt={image.title} 
                            />
                        ))}
                    </div>
                )}
            </div>
        );
    };

    return (
        <div className="speech-input-panel">
            <div className="speech-controls">
                <select 
                    value={searchType} 
                    onChange={(e) => setSearchType(e.target.value)}
                    className="search-type-selector"
                >
                    <option value="text">Text Search</option>
                    <option value="image">Image Search</option>
                    <option value="lens">Google Lens</option>
                </select>

                <div className="mic-container">
                    {!isListening ? (
                        <button 
                            onClick={handleStartListening} 
                            className="mic-button"
                        >
                            ðŸŽ¤ Start Listening
                        </button>
                    ) : (
                        <button 
                            onClick={handleStopListening} 
                            className="mic-button listening"
                        >
                            â¹ï¸ Stop Listening
                        </button>
                    )}
                </div>

                <button 
                    onClick={performSearch} 
                    disabled={!transcript}
                    className="search-button"
                >
                    ðŸ” Search
                </button>
            </div>

            <div className="transcript-display">
                <h3>Transcript</h3>
                <p>{transcript}</p>
                {interimTranscript && (
                    <p className="interim-transcript">{interimTranscript}</p>
                )}
            </div>

            {renderAIEmotion()}
            {renderPerplexityContext()}
            {renderSearchResults()}
        </div>
    );
};

export default SpeechInputPanel;
    </script>
    <script>
        // Google API Integrations for HUD
        const googleApiManager = {
            // Fitness API
            async getFitnessSteps(days = 7) {
                try {
                    const response = await fetch(`/api/fitness/steps?days=${days}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching fitness steps:', error);
                    return null;
                }
            },
            
            async getFitnessHeartRate(days = 1) {
                try {
                    const response = await fetch(`/api/fitness/heart-rate?days=${days}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching heart rate:', error);
                    return null;
                }
            },
            
            async getFitnessSummary(days = 7) {
                try {
                    const response = await fetch(`/api/fitness/summary?days=${days}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching fitness summary:', error);
                    return null;
                }
            },
            
            // Gmail API
            async getGmailMessages(max = 10) {
                try {
                    const response = await fetch(`/api/gmail/messages?max=${max}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching Gmail messages:', error);
                    return null;
                }
            },
            
            async getGmailUnreadCount() {
                try {
                    const response = await fetch('/api/gmail/unread');
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching Gmail unread count:', error);
                    return null;
                }
            },
            
            // Photos API
            async getRecentPhotos(max = 12) {
                try {
                    const response = await fetch(`/api/photos/recent?max=${max}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching recent photos:', error);
                    return null;
                }
            },
            
            async getPhotoAlbums(max = 10) {
                try {
                    const response = await fetch(`/api/photos/albums?max=${max}`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching photo albums:', error);
                    return null;
                }
            },
            
            // Drive API
            async getDriveFiles(max = 20, query = null) {
                try {
                    let url = `/api/drive/files?max=${max}`;
                    if (query) {
                        url += `&q=${encodeURIComponent(query)}`;
                    }
                    const response = await fetch(url);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching Drive files:', error);
                    return null;
                }
            },
            
            // Immersive XR API
            async getXRStreams() {
                try {
                    const response = await fetch('/api/xr/streams');
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching XR streams:', error);
                    return null;
                }
            },
            
            async getXRStreamUrl(streamId) {
                try {
                    const response = await fetch(`/api/xr/stream/${streamId}/url`);
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching XR stream URL:', error);
                    return null;
                }
            }
        };
        
        // Update HUD with data from Google APIs
        async function updateGoogleApiPanels() {
            try {
                // Update fitness panel
                const fitnessSummary = await googleApiManager.getFitnessSummary();
                if (fitnessSummary) {
                    updateFitnessPanel(fitnessSummary);
                }
                
                // Update Gmail panel
                const gmailData = await googleApiManager.getGmailMessages();
                const unreadData = await googleApiManager.getGmailUnreadCount();
                if (gmailData && unreadData) {
                    updateGmailPanel(gmailData.messages, unreadData.unread_count);
                }
                
                // Update Photos panel
                const photosData = await googleApiManager.getRecentPhotos();
                if (photosData) {
                    updatePhotosPanel(photosData.photos);
                }
                
                // Update Drive panel
                const driveData = await googleApiManager.getDriveFiles();
                if (driveData) {
                    updateDrivePanel(driveData.files);
                }
                
                // Check if XR streams are available
                const xrData = await googleApiManager.getXRStreams();
                if (xrData && xrData.streams && xrData.streams.length > 0) {
                    updateXRPanel(xrData.streams);
                }
            } catch (error) {
                console.error('Error updating Google API panels:', error);
            }
        }
        
        // Update fitness panel with data
        function updateFitnessPanel(data) {
            const fitnessPanel = document.getElementById('fitness-panel');
            if (!fitnessPanel) return;
            
            fitnessPanel.innerHTML = `
                <div class="panel-header">
                    <div>FITNESS TRACKER</div>
                    <div class="highlight">ACTIVE</div>
                </div>
                <div class="fitness-summary">
                    <div class="stat-box">
                        <div class="stat-label">TOTAL STEPS</div>
                        <div class="stat-value">${data.total_steps.toLocaleString()}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">AVG STEPS</div>
                        <div class="stat-value">${Math.round(data.avg_steps).toLocaleString()}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">TOTAL CALORIES</div>
                        <div class="stat-value">${Math.round(data.total_calories).toLocaleString()}</div>
                    </div>
                </div>
                <div class="fitness-chart">
                    ${generateActivityChart(data.daily_data)}
                </div>
            `;
        }
        
        // Generate HTML chart for activity data
        function generateActivityChart(dailyData) {
            if (!dailyData || dailyData.length === 0) return '<div class="no-data">No activity data available</div>';
            
            // Sort by date
            dailyData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Find max steps for scaling
            const maxSteps = Math.max(...dailyData.map(day => day.steps || 0));
            
            // Generate HTML for each bar
            let chartHtml = '<div class="bar-chart">';
            
            dailyData.forEach(day => {
                const date = new Date(day.date);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
                const dayDate = date.toLocaleDateString('en-US', { day: 'numeric' });
                const steps = day.steps || 0;
                const percentage = maxSteps ? (steps / maxSteps * 100) : 0;
                
                chartHtml += `
                    <div class="bar-group">
                        <div class="bar-container">
                            <div class="bar" style="height: ${percentage}%"></div>
                        </div>
                        <div class="bar-label">${dayName}<br>${dayDate}</div>
                    </div>
                `;
            });
            
            chartHtml += '</div>';
            return chartHtml;
        }
        
        // Update Gmail panel with data
        function updateGmailPanel(messages, unreadCount) {
            const gmailPanel = document.getElementById('gmail-panel');
            if (!gmailPanel) return;
            
            let messagesHtml = '';
            
            if (messages && messages.length > 0) {
                messages.forEach(msg => {
                    const unreadClass = msg.unread ? 'unread' : '';
                    messagesHtml += `
                        <div class="email-item ${unreadClass}" data-id="${msg.id}">
                            <div class="email-from">${msg.from_name}</div>
                            <div class="email-subject">${msg.subject}</div>
                            <div class="email-snippet">${msg.snippet}</div>
                            <div class="email-date">${formatEmailDate(msg.date)}</div>
                        </div>
                    `;
                });
            } else {
                messagesHtml = '<div class="no-data">No messages available</div>';
            }
            
            gmailPanel.innerHTML = `
                <div class="panel-header">
                    <div>GMAIL INBOX</div>
                    <div class="highlight">UNREAD: ${unreadCount}</div>
                </div>
                <div class="email-list">
                    ${messagesHtml}
                </div>
            `;
            
            // Add click event for emails
            const emailItems = gmailPanel.querySelectorAll('.email-item');
            emailItems.forEach(item => {
                item.addEventListener('click', () => {
                    const messageId = item.dataset.id;
                    openEmailDetails(messageId);
                });
            });
        }
        
        // Format email date
        function formatEmailDate(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            
            // Today
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            }
            
            // Within the last 7 days
            const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
            if (diffDays < 7) {
                return date.toLocaleDateString('en-US', { weekday: 'short' });
            }
            
            // Older
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        // Open email details
        async function openEmailDetails(messageId) {
            try {
                const response = await fetch(`/api/gmail/message/${messageId}`);
                const message = await response.json();
                
                // Create modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="email-subject">${message.subject}</div>
                            <span class="close-modal">&times;</span>
                        </div>
                        <div class="email-details">
                            <div class="email-from">From: ${message.from}</div>
                            <div class="email-to">To: ${message.to}</div>
                            <div class="email-date">Date: ${message.date}</div>
                        </div>
                        <div class="email-body">${message.body}</div>
                        ${message.attachments && message.attachments.length > 0 ? `
                            <div class="email-attachments">
                                <div class="attachment-header">Attachments (${message.attachments.length})</div>
                                <div class="attachment-list">
                                    ${message.attachments.map(att => `
                                        <div class="attachment-item">
                                            <div class="attachment-icon">ðŸ“Ž</div>
                                            <div class="attachment-name">${att.filename}</div>
                                            <div class="attachment-size">${formatFileSize(att.size)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Show modal
                setTimeout(() => {
                    modal.style.opacity = '1';
                }, 10);
                
                // Close button
                const closeBtn = modal.querySelector('.close-modal');
                closeBtn.addEventListener('click', () => {
                    modal.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(modal);
                    }, 300);
                });
                
            } catch (error) {
                console.error('Error opening email details:', error);
            }
        }
        
// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Update Photos panel with data
function updatePhotosPanel(photos) {
    const photosPanel = document.getElementById('photos-panel');
    if (!photosPanel) return;
    
    let photosHtml = '';
    
    if (photos && photos.length > 0) {
        photosHtml = '<div class="photo-grid">';
        photos.forEach(photo => {
            photosHtml += `
                <div class="photo-item" data-id="${photo.id}">
                    <img src="${photo.thumbnail_url}" alt="${photo.filename}" loading="lazy">
                </div>
            `;
        });
        photosHtml += '</div>';
    } else {
        photosHtml = '<div class="no-data">No photos available</div>';
    }
    
    photosPanel.innerHTML = `
        <div class="panel-header">
            <div>RECENT PHOTOS</div>
            <div class="highlight">GALLERY</div>
        </div>
        ${photosHtml}
    `;
    
    // Add click event for photos
    const photoItems = photosPanel.querySelectorAll('.photo-item');
    photoItems.forEach(item => {
        item.addEventListener('click', () => {
            const photoId = item.dataset.id;
            openPhotoViewer(photoId, photos);
        });
    });
}

// Open photo viewer
function openPhotoViewer(photoId, photos) {
    // Find the selected photo
    const selectedPhoto = photos.find(photo => photo.id === photoId);
    if (!selectedPhoto) return;
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal photo-viewer';
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <div class="photo-title">${selectedPhoto.filename}</div>
                <span class="close-modal">&times;</span>
            </div>
            <div class="photo-container">
                <img src="${selectedPhoto.large_url}" alt="${selectedPhoto.filename}">
            </div>
            <div class="photo-details">
                <div class="photo-date">${new Date(selectedPhoto.creation_time).toLocaleString()}</div>
                <div class="photo-dimensions">${selectedPhoto.width} Ã— ${selectedPhoto.height}</div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Show modal
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
    
    // Close button
    const closeBtn = modal.querySelector('.close-modal');
    closeBtn.addEventListener('click', () => {
        modal.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(modal);
        }, 300);
    });
}

// Update Drive panel with data
function updateDrivePanel(files) {
    const drivePanel = document.getElementById('drive-panel');
    if (!drivePanel) return;
    
    let filesHtml = '';
    
    if (files && files.length > 0) {
        filesHtml = '<div class="file-list">';
        files.forEach(file => {
            const typeIcon = getFileTypeIcon(file.type);
            filesHtml += `
                <div class="file-item" data-id="${file.id}" data-type="${file.type}">
                    <div class="file-icon">${typeIcon}</div>
                    <div class="file-details">
                        <div class="file-name">${file.name}</div>
                        <div class="file-meta">
                            <span class="file-type">${file.type}</span>
                            ${file.size ? `<span class="file-size">${formatFileSize(parseInt(file.size))}</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
        });
        filesHtml += '</div>';
    } else {
        filesHtml = '<div class="no-data">No files available</div>';
    }
    
    drivePanel.innerHTML = `
        <div class="panel-header">
            <div>GOOGLE DRIVE</div>
            <div class="highlight">FILES</div>
        </div>
        <div class="drive-search">
            <input type="text" id="drive-search-input" placeholder="Search files...">
            <button id="drive-search-button">Search</button>
        </div>
        ${filesHtml}
    `;
    
    // Add event listeners
    const searchInput = document.getElementById('drive-search-input');
    const searchButton = document.getElementById('drive-search-button');
    
    searchButton.addEventListener('click', () => {
        searchDriveFiles(searchInput.value);
    });
    
    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            searchDriveFiles(searchInput.value);
        }
    });
    
    // Add click event for files and folders
    const fileItems = drivePanel.querySelectorAll('.file-item');
    fileItems.forEach(item => {
        item.addEventListener('click', () => {
            const fileId = item.dataset.id;
            const fileType = item.dataset.type;
            
            if (fileType === 'folder') {
                openFolder(fileId);
            } else {
                openFilePreview(fileId, files.find(f => f.id === fileId));
            }
        });
    });
}

// Get icon for file type
function getFileTypeIcon(type) {
    const icons = {
        'folder': 'ðŸ“',
        'document': 'ðŸ“„',
        'spreadsheet': 'ðŸ“Š',
        'presentation': 'ðŸ“‘',
        'pdf': 'ðŸ“‹',
        'image': 'ðŸ–¼ï¸',
        'video': 'ðŸŽ¬',
        'audio': 'ðŸŽµ',
        'other': 'ðŸ“Ž'
    };
    
    return icons[type] || icons['other'];
}

// Search Drive files
async function searchDriveFiles(query) {
    if (!query) return;
    
    try {
        const driveData = await googleApiManager.getDriveFiles(20, query);
        if (driveData) {
            updateDrivePanel(driveData.files);
        }
    } catch (error) {
        console.error('Error searching Drive files:', error);
    }
}

// Open folder
async function openFolder(folderId) {
    try {
        const response = await fetch(`/api/drive/folder/${folderId}`);
        const data = await response.json();
        updateDrivePanel(data.files);
    } catch (error) {
        console.error('Error opening folder:', error);
    }
}

// Open file preview
function openFilePreview(fileId, fileData) {
    if (!fileData) return;
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal file-preview';
    
    // Generate preview based on file type
    let previewHtml = '';
    
    if (fileData.type === 'image') {
        previewHtml = `<img src="${fileData.thumbnail_link}" alt="${fileData.name}" class="preview-image">`;
    } else if (fileData.type === 'video') {
        previewHtml = `<div class="preview-placeholder">Video Preview Not Available</div>`;
    } else if (fileData.type === 'pdf') {
        previewHtml = `<iframe src="${fileData.web_view_link}" class="preview-iframe"></iframe>`;
    } else {
        previewHtml = `
            <div class="preview-placeholder">
                <div class="file-icon large">${getFileTypeIcon(fileData.type)}</div>
                <div class="preview-message">Preview not available</div>
            </div>
        `;
    }
    
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <div class="file-name">${fileData.name}</div>
                <span class="close-modal">&times;</span>
            </div>
            <div class="file-preview-container">
                ${previewHtml}
            </div>
            <div class="file-actions">
                <a href="${fileData.web_view_link}" target="_blank" class="action-button">Open in Drive</a>
                <a href="/api/drive/download/${fileId}" class="action-button">Download</a>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Show modal
    setTimeout(() => {
        modal.style.opacity = '1';
    }, 10);
    
    // Close button
    const closeBtn = modal.querySelector('.close-modal');
    closeBtn.addEventListener('click', () => {
        modal.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(modal);
        }, 300);
    });
}

// Update XR panel with data
function updateXRPanel(streams) {
    const xrPanel = document.getElementById('xr-panel');
    if (!xrPanel) return;
    
    let streamsHtml = '';
    
    if (streams && streams.length > 0) {
        streamsHtml = '<div class="xr-streams">';
        streams.forEach(stream => {
            streamsHtml += `
                <div class="xr-stream-item" data-id="${stream.name}">
                    <div class="stream-name">${stream.displayName || 'XR Experience'}</div>
                    <div class="stream-description">${stream.description || 'Interactive XR content'}</div>
                    <button class="launch-button" data-id="${stream.name}">Launch</button>
                </div>
            `;
        });
        streamsHtml += '</div>';
    } else {
        streamsHtml = '<div class="no-data">No XR experiences available or API not configured</div>';
    }
    
    xrPanel.innerHTML = `
        <div class="panel-header">
            <div>IMMERSIVE XR</div>
            <div class="highlight">${streams && streams.length > 0 ? 'EXPERIENCES' : 'UNAVAILABLE'}</div>
        </div>
        ${streamsHtml}
    `;
    
    // Add click event for launch buttons
    const launchButtons = xrPanel.querySelectorAll('.launch-button');
    launchButtons.forEach(button => {
        button.addEventListener('click', () => {
            const streamId = button.dataset.id;
            launchXRExperience(streamId);
        });
    });
}

// Launch XR experience
async function launchXRExperience(streamId) {
    try {
        const response = await googleApiManager.getXRStreamUrl(streamId);
        
        if (response && response.url) {
            // Create modal for XR experience
            const modal = document.createElement('div');
            modal.className = 'modal xr-experience-modal';
            modal.innerHTML = `
                <div class="modal-content fullscreen">
                    <div class="modal-header">
                        <div class="xr-title">Immersive XR Experience</div>
                        <span class="close-modal">&times;</span>
                    </div>
                    <div class="xr-container">
                        <iframe src="${response.url}" allowfullscreen="true" class="xr-iframe"></iframe>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Show modal
            setTimeout(() => {
                modal.style.opacity = '1';
            }, 10);
            
            // Close button
            const closeBtn = modal.querySelector('.close-modal');
            closeBtn.addEventListener('click', () => {
                modal.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            });
        } else {
            console.error('Failed to get XR stream URL');
        }
    } catch (error) {
        console.error('Error launching XR experience:', error);
    }
}

// Initialize Google API panels and update periodically
document.addEventListener('DOMContentLoaded', () => {
    // Add panels to HUD if they don't exist
    const hudContainer = document.getElementById('hud-container');
    if (hudContainer) {
        // Check if panels exist, if not create them
        if (!document.getElementById('fitness-panel')) {
            const fitnessPanel = document.createElement('div');
            fitnessPanel.id = 'fitness-panel';
            fitnessPanel.className = 'panel';
            hudContainer.appendChild(fitnessPanel);
        }
        
        if (!document.getElementById('gmail-panel')) {
            const gmailPanel = document.createElement('div');
            gmailPanel.id = 'gmail-panel';
            gmailPanel.className = 'panel';
            hudContainer.appendChild(gmailPanel);
        }
        
        if (!document.getElementById('photos-panel')) {
            const photosPanel = document.createElement('div');
            photosPanel.id = 'photos-panel';
            photosPanel.className = 'panel';
            hudContainer.appendChild(photosPanel);
        }
        
        if (!document.getElementById('drive-panel')) {
            const drivePanel = document.createElement('div');
            drivePanel.id = 'drive-panel';
            drivePanel.className = 'panel';
            hudContainer.appendChild(drivePanel);
        }
        
        if (!document.getElementById('xr-panel')) {
            const xrPanel = document.createElement('div');
            xrPanel.id = 'xr-panel';
            xrPanel.className = 'panel';
            hudContainer.appendChild(xrPanel);
        }
    }
    
    // Initial update
    updateGoogleApiPanels();
    
    // Update every 60 seconds
    setInterval(updateGoogleApiPanels, 60000);
});
</script>
<script>
    // Add these script tags to your index.html
// Conversation Panel Integration
document.addEventListener('DOMContentLoaded', function() {
    // Create a script element for the conversation panel
    const conversationPanelScript = document.createElement('script');
    conversationPanelScript.src = 'conversation-panel.js';
    document.head.appendChild(conversationPanelScript);
    
    // Add event listener for the chat toggle button
    const chatToggleButton = document.getElementById('chatToggleButton');
    if (!chatToggleButton) {
        // If the button doesn't exist, create it
        const button = document.createElement('div');
        button.className = 'chat-toggle-button';
        button.id = 'chatToggleButton';
        button.innerHTML = 'Chat';
        document.body.appendChild(button);
        
        // Add click event listener
        button.addEventListener('click', function() {
            const panel = document.querySelector('.conversation-panel');
            if (panel) {
                panel.classList.toggle('active');
                button.classList.toggle('active');
                
                // If opening, load conversation history
                if (panel.classList.contains('active')) {
                    fetch('/api/conversation/history')
                        .then(response => response.json())
                        .then(data => {
                            const conversationHistory = document.getElementById('conversationHistory');
                            if (conversationHistory && data.conversations) {
                                data.conversations.forEach(item => {
                                    addMessageToHistory('user', item.user_message, new Date(item.timestamp));
                                    addMessageToHistory('ai', item.ai_response, new Date(item.timestamp));
                                });
                                conversationHistory.scrollTop = conversationHistory.scrollHeight;
                            }
                        })
                        .catch(error => console.error('Error loading conversation history:', error));
                }
            }
        });
    }
    
    // Add Adult Features UI script
    const adultFeaturesScript = document.createElement('script');
    adultFeaturesScript.src = 'adult-features-ui.js';
    document.head.appendChild(adultFeaturesScript);
});

// Function to integrate conversation panel with main app
function integrateConversationPanel() {
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendMessage');
    const conversationHistory = document.getElementById('conversationHistory');
    
    if (!messageInput || !sendButton || !conversationHistory) {
        console.error('Conversation panel elements not found. Make sure conversation-panel.js is loaded first.');
        return;
    }
    
    // Connect to main chat system
    sendButton.addEventListener('click', function() {
        const message = messageInput.value.trim();
        if (!message) return;
        
        // Add message to history
        addMessageToHistory('user', message);
        
        // Clear input
        messageInput.value = '';
        
        // Send to backend
        fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: message,
                model: document.getElementById('model-type')?.value || 'llama'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.response) {
                addMessageToHistory('ai', data.response);
            }
        })
        .catch(error => {
            console.error('Error sending message:', error);
            addMessageToHistory('ai', 'Sorry, I encountered an error processing your request.');
        });
    });
    
    // Connect microphone button to speech recognition
    const micToggle = document.getElementById('micToggle');
    if (micToggle) {
        micToggle.addEventListener('click', function() {
            // Initialize WebSpeech API if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    messageInput.value = transcript;
                    sendButton.click();
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                };
                
                recognition.start();
            } else {
                alert('Speech recognition is not supported in your browser.');
            }
        });
    }
}

// Call this after conversation-panel.js is loaded
setTimeout(integrateConversationPanel, 1000);
    </script>
    <script>
        // adult-features-ui.js
// Implements UI components for adult-oriented features

document.addEventListener('DOMContentLoaded', function() {
    // Create UI components for adult features if they don't exist
    createAdultFeaturesUI();
});
// Variable to track if speech is enabled
let isSpeechEnabled = true;
let useServerTTS = true; // Default to using Cloudflare TTS

// Speech synthesis function using Cloudflare TTS API
async function speakCloudflareResponse(text) {
    try {
        if (!isSpeechEnabled) return false;
        
        const response = await fetch('/api/text-to-speech', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                text: text,
                voice: 'female' // Or get from user preference
            })
        });
        
        const data = await response.json();
        
        if (data.error) {
            console.error('TTS error:', data.error);
            // Fall back to browser TTS
            return speakBrowserResponse(text);
        }
        
        // Play the audio
        const audio = new Audio(data.audio);
        
        // Add event listeners for debugging
        audio.onplay = () => console.log('TTS audio playback started');
        audio.onended = () => console.log('TTS audio playback ended');
        audio.onerror = (e) => console.error('TTS audio playback error:', e);
        
        // Play the audio
        audio.play();
        return true;
    } catch (error) {
        console.error('Error with Cloudflare TTS:', error);
        // Fall back to browser TTS
        return speakBrowserResponse(text);
    }
}

// Browser-based TTS as fallback
function speakBrowserResponse(text) {
    // Check if browser supports speech synthesis and if speech is enabled
    if (!isSpeechEnabled) return false;
    
    if ('speechSynthesis' in window) {
        // Create a new speech synthesis utterance
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Optional settings
        utterance.lang = 'en-US';
        utterance.volume = 1.0; // 0 to 1
        utterance.rate = 1.0;   // 0.1 to 10
        utterance.pitch = 1.0;  // 0 to 2
        
        // Get available voices and set a preferred one
        const voices = window.speechSynthesis.getVoices();
        // Try to find a female voice
        const femaleVoice = voices.find(voice => 
            voice.name.includes('Female') || 
            voice.name.includes('woman') || 
            voice.name.includes('girl'));
        
        if (femaleVoice) {
            utterance.voice = femaleVoice;
        }
        
        // Speak the response
        window.speechSynthesis.speak(utterance);
        
        return true;
    } else {
        console.error('Speech synthesis not supported in this browser');
        return false;
    }
}

// Wrapper function to choose the appropriate TTS method
function speakResponse(text) {
    if (useServerTTS) {
        return speakCloudflareResponse(text);
    } else {
        return speakBrowserResponse(text);
    }
}

// Update addMessageToHistory function to include speech
function addMessageToHistory(role, content, timestamp = new Date()) {
    const historyContainer = document.getElementById('conversationHistory');
    
    // Create and append message UI elements...
    
    // Speak the response if it's from the AI
    if (role === 'ai') {
        speakResponse(content);
    }
}

// Add speech toggle button to the UI
document.addEventListener('DOMContentLoaded', function() {
    const controlButtons = document.querySelector('.control-buttons');
    if (controlButtons) {
        // Add speech toggle button if it doesn't exist
        if (!document.getElementById('speechToggle')) {
            const speechToggle = document.createElement('button');
            speechToggle.className = 'control-button';
            speechToggle.id = 'speechToggle';
            speechToggle.innerHTML = 'ðŸ”Š Speech';
            speechToggle.classList.toggle('active', isSpeechEnabled);
            controlButtons.appendChild(speechToggle);
            
            // Add speech toggle functionality
            speechToggle.addEventListener('click', () => {
                isSpeechEnabled = !isSpeechEnabled;
                speechToggle.innerHTML = isSpeechEnabled ? 'ðŸ”Š Speech' : 'ðŸ”‡ Muted';
                speechToggle.classList.toggle('active', isSpeechEnabled);
                
                // If turning off, cancel any ongoing speech
                if (!isSpeechEnabled) {
                    if (window.speechSynthesis) {
                        window.speechSynthesis.cancel();
                    }
                }
            });
        }
    }
});
function createAdultFeaturesUI() {
    // Create settings panel for adult features
    const settingsPanel = document.createElement('div');
    settingsPanel.id = 'adult-features-settings';
    settingsPanel.className = 'settings-panel';
    settingsPanel.style.display = 'none';
    
    settingsPanel.innerHTML = `
        <h3>Adult Features</h3>
        <div class="settings-section">
            <h4>Consent & Privacy</h4>
            <p>These features require explicit consent and age verification.</p>
            <div class="consent-controls">
                <label>
                    <input type="checkbox" id="consent-roleplay"> Enable Erotic Roleplay
                </label>
                <label>
                    <input type="checkbox" id="consent-joi"> Enable Guided Sessions
                </label>
                <label>
                    <input type="checkbox" id="consent-gender"> Enable Gender Recognition
                </label>
            </div>
            <div class="safety-controls">
                <label for="safe-word">Safe Word:</label>
                <input type="text" id="safe-word" placeholder="Enter safe word">
                <button id="set-safe-word">Set</button>
            </div>
        </div>
        
        <div class="feature-section" id="roleplay-section">
            <h4>Erotic Roleplay</h4>
            <div class="roleplay-controls">
                <select id="roleplay-persona">
                    <option value="">Select Persona</option>
                </select>
                <select id="roleplay-scenario">
                    <option value="">Select Scenario</option>
                </select>
                <button id="start-roleplay">Start Session</button>
            </div>
            <div id="active-roleplay-sessions"></div>
        </div>
        
        <div class="feature-section" id="joi-section">
            <h4>Guided Sessions</h4>
            <div class="joi-controls">
                <select id="joi-template">
                    <option value="">Select Session Template</option>
                </select>
                <div class="joi-preferences">
                    <label>
                        Intensity:
                        <select id="joi-intensity">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                        </select>
                    </label>
                    <label>
                        Duration (minutes):
                        <input type="number" id="joi-duration" min="5" max="30" value="10">
                    </label>
                </div>
                <button id="start-joi">Start Session</button>
            </div>
            <div id="active-joi-sessions"></div>
        </div>
        
        <div class="feature-section" id="gender-recognition-section">
            <h4>Gender Recognition</h4>
            <div class="gender-controls">
                <input type="file" id="gender-image" accept="image/*">
                <button id="detect-gender">Detect Gender</button>
            </div>
            <div id="gender-results"></div>
        </div>
        
        <button id="close-adult-features">Close</button>
    `;
    
    document.body.appendChild(settingsPanel);
    
    // Add toggle button for settings panel
    const toggleButton = document.createElement('button');
    toggleButton.id = 'adult-features-toggle';
    toggleButton.className = 'toggle-button';
    toggleButton.innerHTML = 'Adult Features';
    toggleButton.style.position = 'fixed';
    toggleButton.style.bottom = '20px';
    toggleButton.style.left = '20px';
    toggleButton.style.zIndex = '1000';
    toggleButton.style.display = 'none'; // Initially hidden
    
    document.body.appendChild(toggleButton);
    
    // Add styles for the adult features UI
    const styles = document.createElement('style');
    styles.textContent = `
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            background-color: rgba(0, 20, 40, 0.9);
            border: 2px solid #2a9cd0;
            border-radius: 10px;
            padding: 20px;
            z-index: 1050;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
        }
        
        .settings-panel h3 {
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 10px;
            margin-top: 0;
            color: #0ff;
        }
        
        .settings-section, .feature-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(0, 30, 60, 0.6);
            border-radius: 8px;
        }
        
        .settings-section h4, .feature-section h4 {
            margin-top: 0;
            color: #7fbdff;
        }
        
        .consent-controls, .safety-controls, .roleplay-controls, .joi-controls, .gender-controls {
            margin: 15px 0;
        }
        
        .consent-controls label, .joi-preferences label {
            display: block;
            margin-bottom: 10px;
        }
        
        input[type="text"], input[type="number"], select {
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        input[type="file"] {
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-right: 10px;
            margin-bottom: 10px;
            width: calc(100% - 130px);
        }
        
        select {
            width: 100%;
            margin-bottom: 15px;
        }
        
        button {
            background-color: rgba(0, 255, 255, 0.3);
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 8px 15px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }
        
        #close-adult-features {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
        }
        
        #adult-features-toggle {
            background-color: rgba(127, 0, 255, 0.3);
            border: 1px solid rgba(127, 0, 255, 0.5);
            padding: 10px 15px;
        }
        
        #adult-features-toggle:hover {
            background-color: rgba(127, 0, 255, 0.5);
        }
        
        #active-roleplay-sessions, #active-joi-sessions, #gender-results {
            margin-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            padding-top: 15px;
        }
        
        .session-item {
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .session-name {
            font-weight: bold;
            color: #7fbdff;
            margin-bottom: 5px;
        }
        
        .session-controls {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
        }
        
        .roleplay-message-area, .joi-message-area {
            margin-top: 10px;
        }
        
        .message-input {
            width: 100%;
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-bottom: 10px;
            resize: vertical;
            min-height: 60px;
        }
        
        .message-history {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background-color: rgba(0, 20, 40, 0.6);
            border-radius: 4px;
        }
        
        .user-message, .assistant-message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .user-message {
            background-color: rgba(80, 40, 120, 0.4);
            border-left: 3px solid #9370DB;
        }
        
        .assistant-message {
            background-color: rgba(20, 60, 100, 0.4);
            border-left: 3px solid #0ff;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(0, 40, 80, 0.6);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: rgba(0, 255, 255, 0.5);
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .gender-result {
            padding: 15px;
            text-align: center;
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 6px;
        }
        
        .gender-result img {
            max-width: 100%;
            max-height: 200px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .active-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #0f0;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 1.5s infinite;
        }
    `;
    
    document.head.appendChild(styles);
    
    // Add event listeners
    setupEventListeners();
    
    // Load data for dropdowns
    loadRoleplayPersonas();
    loadRoleplayScenarios();
    loadJOITemplates();
    
    // Check consent status and toggle visibility of features
    checkConsentStatus();
}

function setupEventListeners() {
    // Toggle settings panel
    const toggleButton = document.getElementById('adult-features-toggle');
    const settingsPanel = document.getElementById('adult-features-settings');
    const closeButton = document.getElementById('close-adult-features');
    
    toggleButton.addEventListener('click', () => {
        settingsPanel.style.display = 'block';
    });
    
    closeButton.addEventListener('click', () => {
        settingsPanel.style.display = 'none';
    });
    
    // Consent checkboxes
    const consentRoleplay = document.getElementById('consent-roleplay');
    const consentJOI = document.getElementById('consent-joi');
    const consentGender = document.getElementById('consent-gender');
    
    consentRoleplay.addEventListener('change', () => {
        setConsent('erotic_roleplay', consentRoleplay.checked);
    });
    
    consentJOI.addEventListener('change', () => {
        setConsent('joi', consentJOI.checked);
    });
    
    consentGender.addEventListener('change', () => {
        setConsent('gender_recognition', consentGender.checked);
    });
    
    // Safe word
    const safeWordInput = document.getElementById('safe-word');
    const setSafeWordButton = document.getElementById('set-safe-word');
    
    setSafeWordButton.addEventListener('click', () => {
        const safeWord = safeWordInput.value.trim();
        if (safeWord) {
            setSafeWord(safeWord);
        }
    });
    
    // Roleplay controls
    const startRoleplayButton = document.getElementById('start-roleplay');
    
    startRoleplayButton.addEventListener('click', () => {
        const personaId = document.getElementById('roleplay-persona').value;
        const scenarioId = document.getElementById('roleplay-scenario').value;
        
        if (personaId || scenarioId) {
            startRoleplaySession(personaId, scenarioId);
        } else {
            alert('Please select a persona or scenario');
        }
    });
    
    // JOI controls
    const startJOIButton = document.getElementById('start-joi');
    
    startJOIButton.addEventListener('click', () => {
        const templateId = document.getElementById('joi-template').value;
        const intensity = document.getElementById('joi-intensity').value;
        const duration = parseInt(document.getElementById('joi-duration').value);
        
        startJOISession(templateId, intensity, duration);
    });
    
    // Gender recognition
    const detectGenderButton = document.getElementById('detect-gender');
    
    detectGenderButton.addEventListener('click', () => {
        const imageInput = document.getElementById('gender-image');
        
        if (imageInput.files && imageInput.files[0]) {
            detectGender(imageInput.files[0]);
        } else {
            alert('Please select an image');
        }
    });
}

async function checkConsentStatus() {
    try {
        // Call safety API to check consent status
        const response = await fetch('/api/safety/status');
        const data = await response.json();
        
        // Show features button if user is verified
        if (data.is_verified) {
            document.getElementById('adult-features-toggle').style.display = 'block';
        }
        
        // Update consent checkboxes
        if (data.consent_settings) {
            document.getElementById('consent-roleplay').checked = !!data.consent_settings.erotic_roleplay;
            document.getElementById('consent-joi').checked = !!data.consent_settings.joi;
            document.getElementById('consent-gender').checked = !!data.consent_settings.gender_recognition;
        }
        
        // Update UI based on consent
        updateFeaturesVisibility(data.consent_settings || {});
    } catch (error) {
        console.error('Error checking consent status:', error);
    }
}

function updateFeaturesVisibility(consentSettings) {
    // Show/hide feature sections based on consent
    document.getElementById('roleplay-section').style.display = 
        consentSettings.erotic_roleplay ? 'block' : 'none';
    
    document.getElementById('joi-section').style.display = 
        consentSettings.joi ? 'block' : 'none';
    
    document.getElementById('gender-recognition-section').style.display = 
        consentSettings.gender_recognition ? 'block' : 'none';
}

async function setConsent(featureType, hasConsent) {
    try {
        const response = await fetch('/api/safety/consent', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                feature_type: featureType,
                has_consent: hasConsent
            })
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Update UI based on new consent settings
            updateFeaturesVisibility({
                ...document.getElementById('consent-roleplay').checked && { erotic_roleplay: true },
                ...document.getElementById('consent-joi').checked && { joi: true },
                ...document.getElementById('consent-gender').checked && { gender_recognition: true }
            });
        } else {
            console.error('Error setting consent:', data.message);
            // Reset checkbox to previous state
            document.getElementById(`consent-${featureType}`).checked = !hasConsent;
        }
    } catch (error) {
        console.error('Error setting consent:', error);
    }
}

async function setSafeWord(safeWord) {
    try {
        // Set for roleplay
        const roleplayResponse = await fetch('/api/roleplay/safe-word', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                safe_word: safeWord
            })
        });
        
        // Set for JOI
        const joiResponse = await fetch('/api/joi/safe-word', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                safe_word: safeWord
            })
        });
        
        const roleplayData = await roleplayResponse.json();
        const joiData = await joiResponse.json();
        
        if (roleplayData.status === 'success' && joiData.status === 'success') {
            alert(`Safe word set successfully: "${safeWord}"`);
        } else {
            alert('Error setting safe word');
        }
    } catch (error) {
        console.error('Error setting safe word:', error);
        alert('Error setting safe word');
    }
}

// adult-features-ui.js
// Implements UI components for adult-oriented features

document.addEventListener('DOMContentLoaded', function() {
    // Create UI components for adult features if they don't exist
    createAdultFeaturesUI();
});

function createAdultFeaturesUI() {
    // Create settings panel for adult features
    const settingsPanel = document.createElement('div');
    settingsPanel.id = 'adult-features-settings';
    settingsPanel.className = 'settings-panel';
    settingsPanel.style.display = 'none';
    
    settingsPanel.innerHTML = `
        <h3>Adult Features</h3>
        <div class="settings-section">
            <h4>Consent & Privacy</h4>
            <p>These features require explicit consent and age verification.</p>
            <div class="consent-controls">
                <label>
                    <input type="checkbox" id="consent-roleplay"> Enable Erotic Roleplay
                </label>
                <label>
                    <input type="checkbox" id="consent-joi"> Enable Guided Sessions
                </label>
                <label>
                    <input type="checkbox" id="consent-gender"> Enable Gender Recognition
                </label>
            </div>
            <div class="safety-controls">
                <label for="safe-word">Safe Word:</label>
                <input type="text" id="safe-word" placeholder="Enter safe word">
                <button id="set-safe-word">Set</button>
            </div>
        </div>
        
        <div class="feature-section" id="roleplay-section">
            <h4>Erotic Roleplay</h4>
            <div class="roleplay-controls">
                <select id="roleplay-persona">
                    <option value="">Select Persona</option>
                </select>
                <select id="roleplay-scenario">
                    <option value="">Select Scenario</option>
                </select>
                <button id="start-roleplay">Start Session</button>
            </div>
            <div id="active-roleplay-sessions"></div>
        </div>
        
        <div class="feature-section" id="joi-section">
            <h4>Guided Sessions</h4>
            <div class="joi-controls">
                <select id="joi-template">
                    <option value="">Select Session Template</option>
                </select>
                <div class="joi-preferences">
                    <label>
                        Intensity:
                        <select id="joi-intensity">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                        </select>
                    </label>
                    <label>
                        Duration (minutes):
                        <input type="number" id="joi-duration" min="5" max="30" value="10">
                    </label>
                </div>
                <button id="start-joi">Start Session</button>
            </div>
            <div id="active-joi-sessions"></div>
        </div>
        
        <div class="feature-section" id="gender-recognition-section">
            <h4>Gender Recognition</h4>
            <div class="gender-controls">
                <input type="file" id="gender-image" accept="image/*">
                <button id="detect-gender">Detect Gender</button>
            </div>
            <div id="gender-results"></div>
        </div>
        
        <button id="close-adult-features">Close</button>
    `;
    
    document.body.appendChild(settingsPanel);
    
    // Add toggle button for settings panel
    const toggleButton = document.createElement('button');
    toggleButton.id = 'adult-features-toggle';
    toggleButton.className = 'toggle-button';
    toggleButton.innerHTML = 'Adult Features';
    toggleButton.style.position = 'fixed';
    toggleButton.style.bottom = '20px';
    toggleButton.style.left = '20px';
    toggleButton.style.zIndex = '1000';
    toggleButton.style.display = 'none'; // Initially hidden
    
    document.body.appendChild(toggleButton);
    
    // Add styles for the adult features UI
    const styles = document.createElement('style');
    styles.textContent = `
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            background-color: rgba(0, 20, 40, 0.9);
            border: 2px solid #2a9cd0;
            border-radius: 10px;
            padding: 20px;
            z-index: 1050;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
        }
        
        .settings-panel h3 {
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 10px;
            margin-top: 0;
            color: #0ff;
        }
        
        .settings-section, .feature-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(0, 30, 60, 0.6);
            border-radius: 8px;
        }
        
        .settings-section h4, .feature-section h4 {
            margin-top: 0;
            color: #7fbdff;
        }
        
        .consent-controls, .safety-controls, .roleplay-controls, .joi-controls, .gender-controls {
            margin: 15px 0;
        }
        
        .consent-controls label, .joi-preferences label {
            display: block;
            margin-bottom: 10px;
        }
        
        input[type="text"], input[type="number"], select {
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        input[type="file"] {
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-right: 10px;
            margin-bottom: 10px;
            width: calc(100% - 130px);
        }
        
        select {
            width: 100%;
            margin-bottom: 15px;
        }
        
        button {
            background-color: rgba(0, 255, 255, 0.3);
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 8px 15px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }
        
        #close-adult-features {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
        }
        
        #adult-features-toggle {
            background-color: rgba(127, 0, 255, 0.3);
            border: 1px solid rgba(127, 0, 255, 0.5);
            padding: 10px 15px;
        }
        
        #adult-features-toggle:hover {
            background-color: rgba(127, 0, 255, 0.5);
        }
        
        #active-roleplay-sessions, #active-joi-sessions, #gender-results {
            margin-top: 15px;
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            padding-top: 15px;
        }
        
        .session-item {
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .session-name {
            font-weight: bold;
            color: #7fbdff;
            margin-bottom: 5px;
        }
        
        .session-controls {
            display: flex;
            justify-content: flex-end;
            margin-top: 10px;
        }
        
        .roleplay-message-area, .joi-message-area {
            margin-top: 10px;
        }
        
        .message-input {
            width: 100%;
            background-color: rgba(0, 40, 80, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            color: #fff;
            padding: 8px;
            margin-bottom: 10px;
            resize: vertical;
            min-height: 60px;
        }
        
        .message-history {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background-color: rgba(0, 20, 40, 0.6);
            border-radius: 4px;
        }
        
        .user-message, .assistant-message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .user-message {
            background-color: rgba(80, 40, 120, 0.4);
            border-left: 3px solid #9370DB;
        }
        
        .assistant-message {
            background-color: rgba(20, 60, 100, 0.4);
            border-left: 3px solid #0ff;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: rgba(0, 40, 80, 0.6);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: rgba(0, 255, 255, 0.5);
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .gender-result {
            padding: 15px;
            text-align: center;
            background-color: rgba(0, 40, 80, 0.4);
            border-radius: 6px;
        }
        
        .gender-result img {
            max-width: 100%;
            max-height: 200px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .active-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #0f0;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 1.5s infinite;
        }
    `;
    
    document.head.appendChild(styles);
    
    // Add event listeners
    setupEventListeners();
    
    // Load data for dropdowns
    loadRoleplayPersonas();
    loadRoleplayScenarios();
    loadJOITemplates();
    
    // Check consent status and toggle visibility of features
    checkConsentStatus();
}

function setupEventListeners() {
    // Toggle settings panel
    const toggleButton = document.getElementById('adult-features-toggle');
    const settingsPanel = document.getElementById('adult-features-settings');
    const closeButton = document.getElementById('close-adult-features');
    
    toggleButton.addEventListener('click', () => {
        settingsPanel.style.display = 'block';
    });
    
    closeButton.addEventListener('click', () => {
        settingsPanel.style.display = 'none';
    });
    
    // Consent checkboxes
    const consentRoleplay = document.getElementById('consent-roleplay');
    const consentJOI = document.getElementById('consent-joi');
    const consentGender = document.getElementById('consent-gender');
    
    consentRoleplay.addEventListener('change', () => {
        setConsent('erotic_roleplay', consentRoleplay.checked);
    });
    
    consentJOI.addEventListener('change', () => {
        setConsent('joi', consentJOI.checked);
    });
    
    consentGender.addEventListener('change', () => {
        setConsent('gender_recognition', consentGender.checked);
    });
    
    // Safe word
    const safeWordInput = document.getElementById('safe-word');
    const setSafeWordButton = document.getElementById('set-safe-word');
    
    setSafeWordButton.addEventListener('click', () => {
        const safeWord = safeWordInput.value.trim();
        if (safeWord) {
            setSafeWord(safeWord);
        }
    });
    
    // Roleplay controls
    const startRoleplayButton = document.getElementById('start-roleplay');
    
    startRoleplayButton.addEventListener('click', () => {
        const personaId = document.getElementById('roleplay-persona').value;
        const scenarioId = document.getElementById('roleplay-scenario').value;
        
        if (personaId || scenarioId) {
            startRoleplaySession(personaId, scenarioId);
        } else {
            alert('Please select a persona or scenario');
        }
    });
    
    // JOI controls
    const startJOIButton = document.getElementById('start-joi');
    
    startJOIButton.addEventListener('click', () => {
        const templateId = document.getElementById('joi-template').value;
        const intensity = document.getElementById('joi-intensity').value;
        const duration = parseInt(document.getElementById('joi-duration').value);
        
        startJOISession(templateId, intensity, duration);
    });
    
    // Gender recognition
    const detectGenderButton = document.getElementById('detect-gender');
    
    detectGenderButton.addEventListener('click', () => {
        const imageInput = document.getElementById('gender-image');
        
        if (imageInput.files && imageInput.files[0]) {
            detectGender(imageInput.files[0]);
        } else {
            alert('Please select an image');
        }
    });
}

async function checkConsentStatus() {
    try {
        // Call safety API to check consent status
        const response = await fetch('/api/safety/status');
        const data = await response.json();
        
        // Show features button if user is verified
        if (data.is_verified) {
            document.getElementById('adult-features-toggle').style.display = 'block';
        }
        
        // Update consent checkboxes
        if (data.consent_settings) {
            document.getElementById('consent-roleplay').checked = !!data.consent_settings.erotic_roleplay;
            document.getElementById('consent-joi').checked = !!data.consent_settings.joi;
            document.getElementById('consent-gender').checked = !!data.consent_settings.gender_recognition;
        }
        
        // Update UI based on consent
        updateFeaturesVisibility(data.consent_settings || {});
    } catch (error) {
        console.error('Error checking consent status:', error);
    }
}

function updateFeaturesVisibility(consentSettings) {
    // Show/hide feature sections based on consent
    document.getElementById('roleplay-section').style.display = 
        consentSettings.erotic_roleplay ? 'block' : 'none';
    
    document.getElementById('joi-section').style.display = 
        consentSettings.joi ? 'block' : 'none';
    
    document.getElementById('gender-recognition-section').style.display = 
        consentSettings.gender_recognition ? 'block' : 'none';
}

async function setConsent(featureType, hasConsent) {
    try {
        const response = await fetch('/api/safety/consent', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                feature_type: featureType,
                has_consent: hasConsent
            })
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Update UI based on new consent settings
            updateFeaturesVisibility({
                ...document.getElementById('consent-roleplay').checked && { erotic_roleplay: true },
                ...document.getElementById('consent-joi').checked && { joi: true },
                ...document.getElementById('consent-gender').checked && { gender_recognition: true }
            });
        } else {
            console.error('Error setting consent:', data.message);
            // Reset checkbox to previous state
            document.getElementById(`consent-${featureType}`).checked = !hasConsent;
        }
    } catch (error) {
        console.error('Error setting consent:', error);
    }
}

async function setSafeWord(safeWord) {
    try {
        // Set for roleplay
        const roleplayResponse = await fetch('/api/roleplay/safe-word', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                safe_word: safeWord
            })
        });
        
        // Set for JOI
        const joiResponse = await fetch('/api/joi/safe-word', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                safe_word: safeWord
            })
        });
        
        const roleplayData = await roleplayResponse.json();
        const joiData = await joiResponse.json();
        
        if (roleplayData.status === 'success' && joiData.status === 'success') {
            alert(`Safe word set successfully: "${safeWord}"`);
        } else {
            alert('Error setting safe word');
        }
    } catch (error) {
        console.error('Error setting safe word:', error);
        alert('Error setting safe word');
    }
}

async function loadRoleplayPersonas() {
    try {
        const response = await fetch('/api/roleplay/personas');
        const data = await response.json();
        
        if (data.status === 'success' && data.personas) {
            const personaSelect = document.getElementById('roleplay-persona');
            personaSelect.innerHTML = '<option value="">Select Persona</option>';
            
            Object.entries(data.personas).forEach(([id, persona]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = persona.name;
                option.title = persona.description;
                personaSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading roleplay personas:', error);
    }
}

async function loadRoleplayScenarios() {
    try {
        const response = await fetch('/api/roleplay/scenarios');
        const data = await response.json();
        
        if (data.status === 'success' && data.scenarios) {
            const scenarioSelect = document.getElementById('roleplay-scenario');
            scenarioSelect.innerHTML = '<option value="">Select Scenario</option>';
            
            Object.entries(data.scenarios).forEach(([id, scenario]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = scenario.title;
                option.title = scenario.description;
                scenarioSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading roleplay scenarios:', error);
    }
}

async function loadJOITemplates() {
    try {
        const response = await fetch('/api/joi/sessions');
        const data = await response.json();
        
        if (data.status === 'success' && data.sessions) {
            const templateSelect = document.getElementById('joi-template');
            templateSelect.innerHTML = '<option value="">Select Session Template</option>';
            
            Object.entries(data.sessions).forEach(([id, session]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = `${session.name} (${session.duration_minutes} min, ${session.intensity})`;
                option.title = session.description;
                templateSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error loading JOI templates:', error);
    }
}

async function startRoleplaySession(personaId, scenarioId) {
    try {
        const response = await fetch('/api/roleplay/session', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                persona_id: personaId,
                scenario_id: scenarioId
            })
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Create UI for the new session
            createRoleplaySessionUI(data);
        } else if (data.requires_consent) {
            alert('You need to enable consent for roleplay features first');
            document.getElementById('consent-roleplay').focus();
        } else if (data.requires_verification) {
            alert('Age verification required for this feature');
        } else {
            alert(`Error starting roleplay session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error starting roleplay session:', error);
        alert('Failed to start roleplay session');
    }
}

function createRoleplaySessionUI(sessionData) {
    const sessionContainer = document.getElementById('active-roleplay-sessions');
    
    // Create session UI
    const sessionElement = document.createElement('div');
    sessionElement.className = 'session-item';
    sessionElement.id = `roleplay-session-${sessionData.session_id}`;
    
    sessionElement.innerHTML = `
        <div class="session-name">
            <span class="active-indicator"></span>
            ${sessionData.scenario.title} with ${sessionData.persona.name}
        </div>
        <div class="session-description">${sessionData.scenario.description}</div>
        <div class="message-history" id="roleplay-history-${sessionData.session_id}">
            <div class="assistant-message">${sessionData.initial_message}</div>
        </div>
        <div class="roleplay-message-area">
            <textarea class="message-input" placeholder="Type your message..."></textarea>
            <div class="session-controls">
                <button class="send-message">Send</button>
                <button class="end-session">End Session</button>
            </div>
        </div>
    `;
    
    sessionContainer.appendChild(sessionElement);
    
    // Add event listeners for session controls
    const messageInput = sessionElement.querySelector('.message-input');
    const sendButton = sessionElement.querySelector('.send-message');
    const endButton = sessionElement.querySelector('.end-session');
    
    sendButton.addEventListener('click', () => {
        const message = messageInput.value.trim();
        if (message) {
            sendRoleplayMessage(sessionData.session_id, message, sessionElement);
            messageInput.value = '';
        }
    });
    
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendButton.click();
        }
    });
    
    endButton.addEventListener('click', () => {
        endRoleplaySession(sessionData.session_id, sessionElement);
    });
}

async function sendRoleplayMessage(sessionId, message, sessionElement) {
    try {
        // Add user message to history immediately
        const historyContainer = sessionElement.querySelector('.message-history');
        const userMessageEl = document.createElement('div');
        userMessageEl.className = 'user-message';
        userMessageEl.textContent = message;
        historyContainer.appendChild(userMessageEl);
        historyContainer.scrollTop = historyContainer.scrollHeight;
        
        // Send to server
        const response = await fetch(`/api/roleplay/session/${sessionId}/message`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message
            })
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Add AI response to history
            const assistantMessageEl = document.createElement('div');
            assistantMessageEl.className = 'assistant-message';
            assistantMessageEl.textContent = data.response;
            historyContainer.appendChild(assistantMessageEl);
            historyContainer.scrollTop = historyContainer.scrollHeight;
        } else if (data.status === 'safe_word') {
            // Safe word used - end session
            const systemMessageEl = document.createElement('div');
            systemMessageEl.className = 'system-message';
            systemMessageEl.textContent = 'Safe word detected. Session ended.';
            historyContainer.appendChild(systemMessageEl);
            
            // Disable controls
            sessionElement.querySelector('.message-input').disabled = true;
            sessionElement.querySelector('.send-message').disabled = true;
            sessionElement.querySelector('.active-indicator').style.backgroundColor = '#ff0000';
        } else {
            // Error
            const errorMessageEl = document.createElement('div');
            errorMessageEl.className = 'error-message';
            errorMessageEl.textContent = `Error: ${data.message}`;
            historyContainer.appendChild(errorMessageEl);
        }
    } catch (error) {
        console.error('Error sending roleplay message:', error);
        
        // Add error message to history
        const historyContainer = sessionElement.querySelector('.message-history');
        const errorMessageEl = document.createElement('div');
        errorMessageEl.className = 'error-message';
        errorMessageEl.textContent = 'Error sending message. Please try again.';
        historyContainer.appendChild(errorMessageEl);
    }
}

async function endRoleplaySession(sessionId, sessionElement) {
    try {
        const response = await fetch(`/api/roleplay/session/${sessionId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Add end notification to history
            const historyContainer = sessionElement.querySelector('.message-history');
            const endMessageEl = document.createElement('div');
            endMessageEl.className = 'system-message';
            endMessageEl.textContent = `Session ended (duration: ${data.duration_minutes} minutes)`;
            historyContainer.appendChild(endMessageEl);
            
            // Disable controls
            sessionElement.querySelector('.message-input').disabled = true;
            sessionElement.querySelector('.send-message').disabled = true;
            sessionElement.querySelector('.end-session').disabled = true;
            sessionElement.querySelector('.active-indicator').style.backgroundColor = '#888';
        } else {
            alert(`Error ending session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error ending roleplay session:', error);
        alert('Failed to end roleplay session');
    }
}

async function startJOISession(templateId, intensity, duration) {
    try {
        // Prepare request data
        const requestData = {};
        
        if (templateId) {
            requestData.template_id = templateId;
        } else {
            // Use custom settings
            requestData.custom_settings = {
                intensity: intensity,
                duration_minutes: duration
            };
        }
        
        const response = await fetch('/api/joi/session', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Create UI for the new session
            createJOISessionUI(data);
        } else if (data.requires_consent) {
            alert('You need to enable consent for JOI features first');
            document.getElementById('consent-joi').focus();
        } else if (data.requires_verification) {
            alert('Age verification required for this feature');
        } else {
            alert(`Error starting JOI session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error starting JOI session:', error);
        alert('Failed to start JOI session');
    }
}

function createJOISessionUI(sessionData) {
    const sessionContainer = document.getElementById('active-joi-sessions');
    
    // Create session UI
    const sessionElement = document.createElement('div');
    sessionElement.className = 'session-item';
    sessionElement.id = `joi-session-${sessionData.session_id}`;
    
    sessionElement.innerHTML = `
        <div class="session-name">
            <span class="active-indicator"></span>
            ${sessionData.name} (${sessionData.duration_minutes} min, ${sessionData.intensity})
        </div>
        <div class="session-description">${sessionData.description}</div>
        <div class="message-history" id="joi-history-${sessionData.session_id}">
            <div class="assistant-message">${sessionData.initial_instruction}</div>
        </div>
        <div class="session-progress">
            <div class="progress-label">Progress: <span class="progress-value">0%</span></div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%"></div>
            </div>
        </div>
        <div class="joi-message-area">
            <div class="session-controls">
                <button class="next-instruction">Next Instruction</button>
                <button class="pause-resume">Pause</button>
                <button class="end-session">End Session</button>
            </div>
        </div>
    `;
    
    sessionContainer.appendChild(sessionElement);
    
    // Add event listeners for session controls
    const nextButton = sessionElement.querySelector('.next-instruction');
    const pauseResumeButton = sessionElement.querySelector('.pause-resume');
    const endButton = sessionElement.querySelector('.end-session');
    
    nextButton.addEventListener('click', () => {
        getNextJOIInstruction(sessionData.session_id, sessionElement);
    });
    
    pauseResumeButton.addEventListener('click', () => {
        if (pauseResumeButton.textContent === 'Pause') {
            pauseJOISession(sessionData.session_id, sessionElement);
        } else {
            resumeJOISession(sessionData.session_id, sessionElement);
        }
    });
    
    endButton.addEventListener('click', () => {
        endJOISession(sessionData.session_id, sessionElement);
    });
    
    // Start progress update interval
    const progressInterval = setInterval(() => {
        updateJOIProgress(sessionData.session_id, sessionElement, progressInterval);
    }, 1000);
    
    // Store interval ID for cleanup
    sessionElement.dataset.progressInterval = progressInterval;
}

async function getNextJOIInstruction(sessionId, sessionElement) {
    try {
        const response = await fetch(`/api/joi/session/${sessionId}/instruction`);
        const data = await response.json();
        
        if (data.status === 'success') {
            // Add instruction to history
            const historyContainer = sessionElement.querySelector('.message-history');
            const instructionEl = document.createElement('div');
            instructionEl.className = 'assistant-message';
            instructionEl.textContent = data.instruction;
            historyContainer.appendChild(instructionEl);
            historyContainer.scrollTop = historyContainer.scrollHeight;
            
            // Update progress display
            updateProgressDisplay(sessionElement, data.session_progress);
        } else if (data.status === 'safe_word') {
            // Safe word used - end session
            const historyContainer = sessionElement.querySelector('.message-history');
            const systemMessageEl = document.createElement('div');
            systemMessageEl.className = 'system-message';
            systemMessageEl.textContent = 'Safe word detected. Session ended.';
            historyContainer.appendChild(systemMessageEl);
            
            // Disable controls
            sessionElement.querySelector('.next-instruction').disabled = true;
            sessionElement.querySelector('.pause-resume').disabled = true;
            sessionElement.querySelector('.active-indicator').style.backgroundColor = '#ff0000';
            
            // Clear progress interval
            clearInterval(parseInt(sessionElement.dataset.progressInterval));
        } else if (data.status === 'completed') {
            // Session completed
            const historyContainer = sessionElement.querySelector('.message-history');
            const completedMessageEl = document.createElement('div');
            completedMessageEl.className = 'system-message';
            completedMessageEl.textContent = 'Session completed.';
            historyContainer.appendChild(completedMessageEl);
            
            // Disable controls
            sessionElement.querySelector('.next-instruction').disabled = true;
            sessionElement.querySelector('.pause-resume').disabled = true;
            sessionElement.querySelector('.active-indicator').style.backgroundColor = '#00ff00';
            
            // Set progress to 100%
            updateProgressDisplay(sessionElement, 100);
            
            // Clear progress interval
            clearInterval(parseInt(sessionElement.dataset.progressInterval));
        } else {
            // Error
            const historyContainer = sessionElement.querySelector('.message-history');
            const errorMessageEl = document.createElement('div');
            errorMessageEl.className = 'error-message';
            errorMessageEl.textContent = `Error: ${data.message}`;
            historyContainer.appendChild(errorMessageEl);
        }
    } catch (error) {
        console.error('Error getting next JOI instruction:', error);
        
        // Add error message to history
        const historyContainer = sessionElement.querySelector('.message-history');
        const errorMessageEl = document.createElement('div');
        errorMessageEl.className = 'error-message';
        errorMessageEl.textContent = 'Error getting next instruction. Please try again.';
        historyContainer.appendChild(errorMessageEl);
    }
}

async function pauseJOISession(sessionId, sessionElement) {
    try {
        const response = await fetch(`/api/joi/session/${sessionId}/pause`, {
            method: 'POST'
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Update button text
            const pauseResumeButton = sessionElement.querySelector('.pause-resume');
            pauseResumeButton.textContent = 'Resume';
            
            // Add pause notification to history
            const historyContainer = sessionElement.querySelector('.message-history');
            const pauseMessageEl = document.createElement('div');
            pauseMessageEl.className = 'system-message';
            pauseMessageEl.textContent = 'Session paused';
            historyContainer.appendChild(pauseMessageEl);
            
            // Clear progress interval
            clearInterval(parseInt(sessionElement.dataset.progressInterval));
        } else {
            alert(`Error pausing session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error pausing JOI session:', error);
        alert('Failed to pause JOI session');
    }
}

async function resumeJOISession(sessionId, sessionElement) {
    try {
        const response = await fetch(`/api/joi/session/${sessionId}/resume`, {
            method: 'POST'
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Update button text
            const pauseResumeButton = sessionElement.querySelector('.pause-resume');
            pauseResumeButton.textContent = 'Pause';
            
            // Add resume notification to history
            const historyContainer = sessionElement.querySelector('.message-history');
            const resumeMessageEl = document.createElement('div');
            resumeMessageEl.className = 'system-message';
            resumeMessageEl.textContent = 'Session resumed';
            historyContainer.appendChild(resumeMessageEl);
            
            // Restart progress interval
            const progressInterval = setInterval(() => {
                updateJOIProgress(sessionId, sessionElement, progressInterval);
            }, 1000);
            
            // Store interval ID for cleanup
            sessionElement.dataset.progressInterval = progressInterval;
        } else {
            alert(`Error resuming session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error resuming JOI session:', error);
        alert('Failed to resume JOI session');
    }
}

async function endJOISession(sessionId, sessionElement) {
    try {
        const response = await fetch(`/api/joi/session/${sessionId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            // Add end notification to history
            const historyContainer = sessionElement.querySelector('.message-history');
            const endMessageEl = document.createElement('div');
            endMessageEl.className = 'system-message';
            endMessageEl.textContent = `Session ended (${data.summary.actual_duration_minutes} minutes)`;
            historyContainer.appendChild(endMessageEl);
            
            // Disable controls
            sessionElement.querySelector('.next-instruction').disabled = true;
            sessionElement.querySelector('.pause-resume').disabled = true;
            sessionElement.querySelector('.end-session').disabled = true;
            sessionElement.querySelector('.active-indicator').style.backgroundColor = '#888';
            
            // Clear progress interval
            clearInterval(parseInt(sessionElement.dataset.progressInterval));
        } else {
            alert(`Error ending session: ${data.message}`);
        }
    } catch (error) {
        console.error('Error ending JOI session:', error);
        alert('Failed to end JOI session');
    }
}

async function updateJOIProgress(sessionId, sessionElement, intervalId) {
    try {
        const response = await fetch(`/api/joi/session/${sessionId}`);
        const data = await response.json();
        
        if (data.status === 'success') {
            const sessionInfo = data.session;
            
            // Update progress display
            updateProgressDisplay(sessionElement, sessionInfo.session_progress);
            
            // Check if session is completed
            if (sessionInfo.completed) {
                // Add completion message if not already added
                const historyContainer = sessionElement.querySelector('.message-history');
                if (!historyContainer.querySelector('.system-message')) {
                    const completedMessageEl = document.createElement('div');
                    completedMessageEl.className = 'system-message';
                    completedMessageEl.textContent = 'Session completed.';
                    historyContainer.appendChild(completedMessageEl);
                }
                
                // Disable controls
                sessionElement.querySelector('.next-instruction').disabled = true;
                sessionElement.querySelector('.pause-resume').disabled = true;
                sessionElement.querySelector('.active-indicator').style.backgroundColor = '#00ff00';
                
                // Clear interval
                clearInterval(intervalId);
            }
        } else {
            // Session not found or error - stop updating
            clearInterval(intervalId);
        }
    } catch (error) {
        console.error('Error updating JOI progress:', error);
        // Don't clear interval on network error - try again
    }
}

function updateProgressDisplay(sessionElement, progressPercent) {
    const progressValue = sessionElement.querySelector('.progress-value');
    const progressFill = sessionElement.querySelector('.progress-fill');
    
    progressValue.textContent = `${Math.round(progressPercent)}%`;
    progressFill.style.width = `${progressPercent}%`;
}

async function detectGender(imageFile) {
    try {
        // Convert image to base64
        const reader = new FileReader();
        
        reader.onload = async function(e) {
            const imageData = e.target.result;
            
            // Send to the API
            const response = await fetch('/api/gender/detect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image: imageData
                })
            });
            
            const data = await response.json();
            
            // Display results
            const resultsContainer = document.getElementById('gender-results');
            
            if (data.status === 'success') {
                resultsContainer.innerHTML = `
                    <div class="gender-result">
                        <img src="${imageData}" alt="Uploaded image">
                        <div class="result-text">
                            <div class="gender-value">Detected gender: <strong>${data.gender}</strong></div>
                            <div class="confidence-value">Confidence: ${(data.confidence * 100).toFixed(2)}%</div>
                            <div class="reliability-indicator">
                                ${data.is_reliable ? 
                                    '<span style="color: #00ff00;">âœ“ Reliable detection</span>' : 
                                    '<span style="color: #ffaa00;">âš  Low confidence detection</span>'}
                            </div>
                        </div>
                    </div>
                `;
            } else if (data.requires_consent) {
                resultsContainer.innerHTML = `
                    <div class="error-message">
                        Consent required for gender recognition.
                        Please enable consent in the settings.
                    </div>
                `;
                document.getElementById('consent-gender').focus();
            } else {
                resultsContainer.innerHTML = `
                    <div class="error-message">
                        Error: ${data.message}
                    </div>
                `;
            }
        };
        
        reader.readAsDataURL(imageFile);
    } catch (error) {
        console.error('Error detecting gender:', error);
        
        const resultsContainer = document.getElementById('gender-results');
        resultsContainer.innerHTML = `
            <div class="error-message">
                An error occurred while processing the image.
                Please try again with a different image.
            </div>
        `;
    }
}
        </script>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                // Set up adult features toggle
                const adultFeaturesToggle = document.getElementById('adultFeaturesToggle');
                const privacyNotice = document.getElementById('privacy-notice');
                const acceptPrivacyButton = document.getElementById('accept-privacy-notice');
                const ageVerificationModal = document.getElementById('age-verification-modal');
                const confirmAgeButton = document.getElementById('confirm-age');
                const cancelVerificationButton = document.getElementById('cancel-verification');
                
                // Show adult features toggle only after privacy notice is accepted
                let privacyAccepted = localStorage.getItem('adult_features_privacy_accepted') === 'true';
                adultFeaturesToggle.style.display = privacyAccepted ? 'flex' : 'none';
                
                // Show privacy notice if not yet accepted
                if (!privacyAccepted) {
                    privacyNotice.style.display = 'block';
                }
                
                // Handle privacy notice acceptance
                acceptPrivacyButton.addEventListener('click', function() {
                    localStorage.setItem('adult_features_privacy_accepted', 'true');
                    privacyNotice.style.display = 'none';
                    adultFeaturesToggle.style.display = 'flex';
                });
                
                // Age verification status
                let ageVerified = localStorage.getItem('age_verified') === 'true';
                
                // Handle adult features toggle click
                adultFeaturesToggle.addEventListener('click', function() {
                    // Check if age verification is required
                    if (!ageVerified) {
                        ageVerificationModal.style.display = 'flex';
                    } else {
                        // Age already verified, show adult features panel
                        showAdultFeaturesPanel();
                    }
                });
                
                // Handle age verification confirmation
                confirmAgeButton.addEventListener('click', function() {
                    ageVerified = true;
                    localStorage.setItem('age_verified', 'true');
                    ageVerificationModal.style.display = 'none';
                    
                    // Verify age with the server
                    verifyAgeWithServer();
                    
                    // Show adult features panel
                    showAdultFeaturesPanel();
                });
                
                // Handle age verification cancellation
                cancelVerificationButton.addEventListener('click', function() {
                    ageVerificationModal.style.display = 'none';
                });
                
                // Function to show adult features panel
                function showAdultFeaturesPanel() {
                    // Check if adult-features-ui.js is loaded
                    if (typeof createAdultFeaturesUI === 'function') {
                        // Script already loaded, just show the panel
                        document.getElementById('adult-features-settings').style.display = 'block';
                    } else {
                        // Load the script dynamically
                        const script = document.createElement('script');
                        script.src = 'adult-features-ui.js';
                        script.onload = function() {
                            // Once loaded, create and show the UI
                            if (typeof createAdultFeaturesUI === 'function') {
                                createAdultFeaturesUI();
                                document.getElementById('adult-features-settings').style.display = 'block';
                            }
                        };
                        document.head.appendChild(script);
                    }
                }
                
                // Function to verify age with the server
                function verifyAgeWithServer() {
                    fetch('/api/safety/verify-age', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            verified: true
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status !== 'success') {
                            console.error('Error verifying age with server:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error verifying age with server:', error);
                    });
                }
                
                // Check if we need to load the adult features script eagerly
                // This can happen if the user has already enabled adult features
                // and we want them to be available immediately upon page load
                if (privacyAccepted && ageVerified && localStorage.getItem('adult_features_enabled') === 'true') {
                    // Load the script in the background
                    const script = document.createElement('script');
                    script.src = 'adult-features-ui.js';
                    document.head.appendChild(script);
                }
            });
                </script>
</body>
</html>